; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\Offi SRC_real\Offi src!\_Database\Query.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NOJCDH@?$CF02x?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OAGAMKLF@00000?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Decrpyt@@YAXPAEPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPWDFromToken@@YAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CQuery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CQuery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisConnect@CQuery@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableConnectionPooling@CQuery@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Connect@CQuery@@QAEHHPAD0PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exec@CQuery@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoreResults@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fetch@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CQuery@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindCol@CQuery@@AAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CQuery@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CQuery@@QAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt64@CQuery@@QAE_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt64@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChar@CQuery@@QAEDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChar@CQuery@@QAEDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintDiag@CQuery@@QAEXPBDF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadBlob@CQuery@@QAEHPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteBlob@CQuery@@QAEXPBDPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteLogFile@CQuery@@QAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareFetch@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CQuery@@QAAHPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Decrpyt@@YAXPAEPAD@Z				; Decrpyt
EXTRN	_des3_set_3keys:NEAR
EXTRN	_des3_decrypt:NEAR
;	COMDAT ?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
; File c:\offi src_real\offi src!\_database\query.cpp
_DATA	SEGMENT
?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA DB 032H		; `Decrpyt'::`2'::keys
	DB	089H
	DB	045H
	DB	09aH
	DB	089H
	DB	0abH
	DB	0cdH
	DB	011H
	DB	023H
	DB	045H
	DB	067H
	DB	089H
	DB	0abH
	DB	0cdH
	DB	0efH
	DB	01H
	DB	01fH
	DB	067H
	DB	089H
	DB	054H
	DB	0cdH
	DB	0efH
	DB	00H
	DB	023H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?Decrpyt@@YAXPAEPAD@Z
_TEXT	SEGMENT
_ctx3$ = -768						; size = 768
_pEncrypted$ = 8					; size = 4
_szResult$ = 12						; size = 4
?Decrpyt@@YAXPAEPAD@Z PROC NEAR				; Decrpyt, COMDAT

; 14   : {

  00000	81 ec 00 03 00
	00		 sub	 esp, 768		; 00000300H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15   : 	static unsigned char keys[3][8] =
; 16   : 	{
; 17   : 		{ 0x32, 0x89, 0x45, 0x9A, 0x89, 0xAB, 0xCD, 0x11 },
; 18   : 		{ 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01 },
; 19   : 		{ 0x1F, 0x67, 0x89, 0x54, 0xCD, 0xEF, 0x00, 0x23 }
; 20   : 	};
; 21   : 
; 22   :     des3_context ctx3;
; 23   :     des3_set_3keys( &ctx3, keys[0], keys[1], keys[2] );

  00009	68 10 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA+16
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA+8
  00013	8d 44 24 14	 lea	 eax, DWORD PTR _ctx3$[esp+788]
  00017	68 00 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _des3_set_3keys
  00022	8b b4 24 20 03
	00 00		 mov	 esi, DWORD PTR _pEncrypted$[esp+792]

; 24   : 
; 25   :     unsigned char* input = pEncrypted;
; 26   :     unsigned char* result = (unsigned char*)szResult;
; 27   : 	for( int i=0; i<3; i++ )

  00029	8b bc 24 24 03
	00 00		 mov	 edi, DWORD PTR _szResult$[esp+792]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	2b fe		 sub	 edi, esi
  00035	bb 03 00 00 00	 mov	 ebx, 3
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L147990:

; 28   : 		des3_decrypt( &ctx3, input + i*8, result + i*8 );

  00040	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  00043	51		 push	 ecx
  00044	8d 54 24 10	 lea	 edx, DWORD PTR _ctx3$[esp+784]
  00048	56		 push	 esi
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _des3_decrypt
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	83 c6 08	 add	 esi, 8
  00055	4b		 dec	 ebx
  00056	75 e8		 jne	 SHORT $L147990
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 29   : }

  0005b	81 c4 00 03 00
	00		 add	 esp, 768		; 00000300H
  00061	c3		 ret	 0
?Decrpyt@@YAXPAEPAD@Z ENDP				; Decrpyt
_TEXT	ENDS
PUBLIC	??_C@_04NOJCDH@?$CF02x?$AA@			; `string'
PUBLIC	?GetPWDFromToken@@YAHPBDPAD@Z			; GetPWDFromToken
EXTRN	_sscanf:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_04NOJCDH@?$CF02x?$AA@
CONST	SEGMENT
??_C@_04NOJCDH@?$CF02x?$AA@ DB '%02x', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetPWDFromToken@@YAHPBDPAD@Z
_TEXT	SEGMENT
_szBuf$148000 = -264					; size = 3
_byPWD$147999 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szToken$ = 8						; size = 4
_szPWD$ = 12						; size = 4
?GetPWDFromToken@@YAHPBDPAD@Z PROC NEAR			; GetPWDFromToken, COMDAT

; 32   : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	55		 push	 ebp

; 33   : 
; 34   : 	int nCount = strlen( szToken ) / 2;

  0000c	8b ac 24 10 01
	00 00		 mov	 ebp, DWORD PTR _szToken$[esp+264]
  00013	89 84 24 08 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+268], eax
  0001a	8b c5		 mov	 eax, ebp
  0001c	57		 push	 edi
  0001d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L148428:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L148428
  00027	2b c2		 sub	 eax, edx
  00029	d1 e8		 shr	 eax, 1
  0002b	8b f8		 mov	 edi, eax

; 35   : 	if( nCount > 0 )

  0002d	85 ff		 test	 edi, edi
  0002f	7e 68		 jle	 SHORT $L147998
  00031	56		 push	 esi

; 36   : 	{
; 37   : 		BYTE byPWD[256];
; 38   : 		char szBuf[3] = {0, };
; 39   : 		for( int i=0; i<nCount; i++ )

  00032	33 f6		 xor	 esi, esi
  00034	85 ff		 test	 edi, edi
  00036	88 4c 24 0c	 mov	 BYTE PTR _szBuf$148000[esp+276], cl
  0003a	66 c7 44 24 0d
	00 00		 mov	 WORD PTR _szBuf$148000[esp+277], 0
  00041	7e 26		 jle	 SHORT $L148004
$L148002:

; 40   : 		{
; 41   : 			memcpy( szBuf, szToken + i*2, 2 );						

  00043	66 8b 44 75 00	 mov	 ax, WORD PTR [ebp+esi*2]

; 42   : 			sscanf( szBuf, "%02x", (byPWD + i) );

  00048	8d 4c 34 10	 lea	 ecx, DWORD PTR _byPWD$147999[esp+esi+276]
  0004c	51		 push	 ecx
  0004d	8d 54 24 10	 lea	 edx, DWORD PTR _szBuf$148000[esp+280]
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04NOJCDH@?$CF02x?$AA@
  00056	52		 push	 edx
  00057	66 89 44 24 18	 mov	 WORD PTR _szBuf$148000[esp+288], ax
  0005c	e8 00 00 00 00	 call	 _sscanf
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	46		 inc	 esi
  00065	3b f7		 cmp	 esi, edi
  00067	7c da		 jl	 SHORT $L148002
$L148004:

; 43   : 		}
; 44   : 		Decrpyt( byPWD, szPWD );

  00069	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR _szPWD$[esp+272]
  00070	50		 push	 eax
  00071	8d 4c 24 14	 lea	 ecx, DWORD PTR _byPWD$147999[esp+280]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?Decrpyt@@YAXPAEPAD@Z	; Decrpyt
  0007b	83 c4 08	 add	 esp, 8
  0007e	5e		 pop	 esi
  0007f	5f		 pop	 edi

; 45   : 		return TRUE;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	5d		 pop	 ebp

; 46   : 	}
; 47   : 	return FALSE;
; 48   : /*
; 49   : 	int i;
; 50   : 	static unsigned char keys[3][8] =
; 51   : 	{
; 52   : 		{ 0x32, 0x89, 0x45, 0x9A, 0x89, 0xAB, 0xCD, 0x11 },
; 53   : 		{ 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01 },
; 54   : 		{ 0x1F, 0x67, 0x89, 0x54, 0xCD, 0xEF, 0x00, 0x23 }
; 55   : 	};
; 56   : 
; 57   :     des3_context ctx3;
; 58   :     des3_set_3keys( &ctx3, keys[0], keys[1], keys[2] );
; 59   : 
; 60   : 	{
; 61   : 		// uncomment this block to make encrypted password
; 62   : 		// unsigned char input[24] = { '1', '2', };       // original password
; 63   : 		unsigned char input[24] = {0, };       // original password
; 64   : 		unsigned char output[24];
; 65   : 		
; 66   : 		strcpy( (char*)input, szToken );
; 67   : 
; 68   : 		for( i=0; i<3; i++ )
; 69   : 		{
; 70   : 			unsigned char buf[8] = { 0, };
; 71   : 			memcpy( buf, input+i*8, 8 );
; 72   : 			des3_encrypt( &ctx3, buf, output + i*8 );
; 73   : 		}
; 74   : 
; 75   : 		char szBuffer[256] = {0, };
; 76   : 		for( i=0; i<24; i++ )
; 77   : 			sprintf( szBuffer+i*2, "%02X", output[i] );
; 78   : 		OutputDebugString( szBuffer );
; 79   : 		
; 80   : 	}
; 81   : 	OutputDebugString( "\n" );
; 82   : */
; 83   : 	return TRUE;
; 84   : }

  00086	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00098	c3		 ret	 0
$L147998:
  00099	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  000a0	5f		 pop	 edi
  000a1	33 c0		 xor	 eax, eax
  000a3	5d		 pop	 ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000af	c3		 ret	 0
?GetPWDFromToken@@YAHPBDPAD@Z ENDP			; GetPWDFromToken
_TEXT	ENDS
PUBLIC	??0CQuery@@QAE@XZ				; CQuery::CQuery
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogty
;	COMDAT ??0CQuery@@QAE@XZ
_TEXT	SEGMENT
??0CQuery@@QAE@XZ PROC NEAR				; CQuery::CQuery, COMDAT
; _this$ = ecx

; 88   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 89   : 	hStmt	= NULL;

  00002	33 c0		 xor	 eax, eax
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	89 87 08 07 00
	00		 mov	 DWORD PTR [edi+1800], eax

; 90   : 	hDbc	= NULL;
; 91   : 	hDbc	= NULL;

  0000d	89 87 04 03 00
	00		 mov	 DWORD PTR [edi+772], eax

; 92   : 	hEnv	= NULL;

  00013	89 87 00 03 00
	00		 mov	 DWORD PTR [edi+768], eax
  00019	8d b7 08 03 00
	00		 lea	 esi, DWORD PTR [edi+776]
  0001f	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
$L148010:

; 93   : 
; 94   : 	for( int i = 0; i < MAXCOL; i++ )
; 95   : 		Col[i]	= new char[8192];

  00024	68 00 20 00 00	 push	 8192			; 00002000H
  00029	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002e	89 06		 mov	 DWORD PTR [esi], eax
  00030	83 c4 04	 add	 esp, 4
  00033	83 c6 04	 add	 esi, 4
  00036	4b		 dec	 ebx
  00037	75 eb		 jne	 SHORT $L148010

; 96   : }

  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	c3		 ret	 0
??0CQuery@@QAE@XZ ENDP					; CQuery::CQuery
_TEXT	ENDS
PUBLIC	??1CQuery@@QAE@XZ				; CQuery::~CQuery
EXTRN	_SQLDisconnect@4:NEAR
EXTRN	_SQLFreeHandle@8:NEAR
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogty
;	COMDAT ??1CQuery@@QAE@XZ
_TEXT	SEGMENT
??1CQuery@@QAE@XZ PROC NEAR				; CQuery::~CQuery, COMDAT
; _this$ = ecx

; 100  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 101  : 	if (hStmt)	SQLFreeHandle(SQL_HANDLE_STMT,hStmt);

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	85 c0		 test	 eax, eax
  0000b	57		 push	 edi
  0000c	74 08		 je	 SHORT $L148018
  0000e	50		 push	 eax
  0000f	6a 03		 push	 3
  00011	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148018:

; 102  : 	if (hDbc)	SQLDisconnect(hDbc);

  00016	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0001c	85 c0		 test	 eax, eax
  0001e	74 06		 je	 SHORT $L148019
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _SQLDisconnect@4
$L148019:

; 103  : 	if (hDbc)	SQLFreeHandle(SQL_HANDLE_DBC,hDbc);

  00026	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0002c	85 c0		 test	 eax, eax
  0002e	74 08		 je	 SHORT $L148020
  00030	50		 push	 eax
  00031	6a 02		 push	 2
  00033	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148020:

; 104  : 	if (hEnv)	SQLFreeHandle(SQL_HANDLE_ENV,hEnv);

  00038	8b 86 00 03 00
	00		 mov	 eax, DWORD PTR [esi+768]
  0003e	85 c0		 test	 eax, eax
  00040	74 08		 je	 SHORT $L148021
  00042	50		 push	 eax
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148021:

; 105  : 
; 106  : 	for( int i = 0; i < MAXCOL; i++ )

  0004a	81 c6 08 03 00
	00		 add	 esi, 776		; 00000308H
  00050	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
$L148023:

; 107  : 		SAFE_DELETE_ARRAY( Col[i] );

  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	85 c0		 test	 eax, eax
  00059	74 0f		 je	 SHORT $L148024
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00061	83 c4 04	 add	 esp, 4
  00064	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$L148024:
  0006a	83 c6 04	 add	 esi, 4
  0006d	4f		 dec	 edi
  0006e	75 e5		 jne	 SHORT $L148023
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 108  : }

  00072	c3		 ret	 0
??1CQuery@@QAE@XZ ENDP					; CQuery::~CQuery
_TEXT	ENDS
PUBLIC	?DisConnect@CQuery@@QAEXXZ			; CQuery::DisConnect
; Function compile flags: /Ogty
;	COMDAT ?DisConnect@CQuery@@QAEXXZ
_TEXT	SEGMENT
?DisConnect@CQuery@@QAEXXZ PROC NEAR			; CQuery::DisConnect, COMDAT
; _this$ = ecx

; 111  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 112  : 	if (hStmt)	SQLFreeHandle(SQL_HANDLE_STMT,hStmt);	hStmt = NULL;

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	3b c7		 cmp	 eax, edi
  0000e	74 08		 je	 SHORT $L148032
  00010	50		 push	 eax
  00011	6a 03		 push	 3
  00013	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148032:

; 113  : 	if (hDbc)	SQLDisconnect(hDbc);

  00018	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0001e	3b c7		 cmp	 eax, edi
  00020	89 be 08 07 00
	00		 mov	 DWORD PTR [esi+1800], edi
  00026	74 06		 je	 SHORT $L148033
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _SQLDisconnect@4
$L148033:

; 114  : 	if (hDbc)	SQLFreeHandle(SQL_HANDLE_DBC,hDbc);		hDbc = NULL;

  0002e	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  00034	3b c7		 cmp	 eax, edi
  00036	74 08		 je	 SHORT $L148034
  00038	50		 push	 eax
  00039	6a 02		 push	 2
  0003b	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148034:

; 115  : 	if (hEnv)	SQLFreeHandle(SQL_HANDLE_ENV,hEnv);		hEnv = NULL;

  00040	8b 86 00 03 00
	00		 mov	 eax, DWORD PTR [esi+768]
  00046	3b c7		 cmp	 eax, edi
  00048	89 be 04 03 00
	00		 mov	 DWORD PTR [esi+772], edi
  0004e	74 08		 je	 SHORT $L148447
  00050	50		 push	 eax
  00051	6a 01		 push	 1
  00053	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L148447:
  00058	89 be 00 03 00
	00		 mov	 DWORD PTR [esi+768], edi
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 116  : }

  00060	c3		 ret	 0
?DisConnect@CQuery@@QAEXXZ ENDP				; CQuery::DisConnect
_TEXT	ENDS
PUBLIC	?EnableConnectionPooling@CQuery@@SAHXZ		; CQuery::EnableConnectionPooling
EXTRN	_SQLSetEnvAttr@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?EnableConnectionPooling@CQuery@@SAHXZ
_TEXT	SEGMENT
?EnableConnectionPooling@CQuery@@SAHXZ PROC NEAR	; CQuery::EnableConnectionPooling, COMDAT

; 122  : 	SQLRETURN result = SQLSetEnvAttr( NULL,  // make process level cursor pooling
; 123  : 					   			     SQL_ATTR_CONNECTION_POOLING,
; 124  : 						             (SQLPOINTER)SQL_CP_ONE_PER_DRIVER,
; 125  : 						             SQL_IS_INTEGER );

  00000	6a fa		 push	 -6			; fffffffaH
  00002	6a 01		 push	 1
  00004	68 c9 00 00 00	 push	 201			; 000000c9H
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16

; 126  : 
; 127  : 	return SQL_SUCCEEDED( result ); 

  00010	83 e0 fe	 and	 eax, -2			; fffffffeH
  00013	66 f7 d8	 neg	 ax
  00016	1b c0		 sbb	 eax, eax
  00018	40		 inc	 eax

; 128  : }

  00019	c3		 ret	 0
?EnableConnectionPooling@CQuery@@SAHXZ ENDP		; CQuery::EnableConnectionPooling
_TEXT	ENDS
PUBLIC	?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z	; CQuery::BindParameter
PUBLIC	??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@ ; `string'
EXTRN	__imp__GetCurrentThreadId@0:NEAR
EXTRN	_SQLBindParameter@40:NEAR
EXTRN	?WriteLog@@YAXPBDZZ:NEAR			; WriteLog
;	COMDAT ??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
CONST	SEGMENT
??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@ DB 'CQuery::B'
	DB	'indParameter - result : %d, ThreadID : %d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z
_TEXT	SEGMENT
_parameterNumber$ = 8					; size = 2
_inputOutputType$ = 12					; size = 2
_valueType$ = 16					; size = 2
_parameterType$ = 20					; size = 2
_columnSize$ = 24					; size = 4
_decimalDigits$ = 28					; size = 2
_parameterValuePtr$ = 32				; size = 4
_bufferLength$ = 36					; size = 4
_strLen_or_IndPtr$ = 40					; size = 4
?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z PROC NEAR	; CQuery::BindParameter, COMDAT
; _this$ = ecx

; 202  : 	SQLRETURN result = ::SQLBindParameter( hStmt, parameterNumber, inputOutputType, valueType, parameterType, columnSize,
; 203  : 		                                decimalDigits, parameterValuePtr, bufferLength, strLen_or_IndPtr );

  00000	8b 44 24 24	 mov	 eax, DWORD PTR _strLen_or_IndPtr$[esp-4]
  00004	8b 54 24 20	 mov	 edx, DWORD PTR _bufferLength$[esp-4]
  00008	8b 89 08 07 00
	00		 mov	 ecx, DWORD PTR [ecx+1800]
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	8b 44 24 24	 mov	 eax, DWORD PTR _parameterValuePtr$[esp+4]
  00014	52		 push	 edx
  00015	8b 54 24 24	 mov	 edx, DWORD PTR _decimalDigits$[esp+8]
  00019	50		 push	 eax
  0001a	8b 44 24 24	 mov	 eax, DWORD PTR _columnSize$[esp+12]
  0001e	52		 push	 edx
  0001f	8b 54 24 24	 mov	 edx, DWORD PTR _parameterType$[esp+16]
  00023	50		 push	 eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR _valueType$[esp+20]
  00028	52		 push	 edx
  00029	8b 54 24 24	 mov	 edx, DWORD PTR _inputOutputType$[esp+24]
  0002d	50		 push	 eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR _parameterNumber$[esp+28]
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _SQLBindParameter@40
  0003a	8b f0		 mov	 esi, eax

; 204  : 	if( result != SQL_SUCCESS )

  0003c	66 85 f6	 test	 si, si
  0003f	74 1e		 je	 SHORT $L148083

; 205  : 	{
; 206  : 		TRACE( "CQuery::BindParameter\n" );
; 207  : 		WriteLog( "CQuery::BindParameter - result : %d, ThreadID : %d", result, ::GetCurrentThreadId() );

  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00047	0f bf d6	 movsx	 edx, si
  0004a	50		 push	 eax
  0004b	52		 push	 edx
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
  00051	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	5e		 pop	 esi

; 212  : }

  0005c	c2 24 00	 ret	 36			; 00000024H
$L148083:

; 209  : 	}
; 210  : 	else
; 211  : 		return TRUE;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 212  : }

  00065	c2 24 00	 ret	 36			; 00000024H
?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z ENDP		; CQuery::BindParameter
_TEXT	ENDS
PUBLIC	?Fetch@CQuery@@QAEHXZ				; CQuery::Fetch
EXTRN	_SQLFetch@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Fetch@CQuery@@QAEHXZ
_TEXT	SEGMENT
?Fetch@CQuery@@QAEHXZ PROC NEAR				; CQuery::Fetch, COMDAT
; _this$ = ecx

; 303  : 	SQLRETURN result = SQLFetch( hStmt );

  00000	8b 81 08 07 00
	00		 mov	 eax, DWORD PTR [ecx+1800]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _SQLFetch@4

; 314  : 
; 315  : 	case SQL_NO_DATA_FOUND:		// == SQL_NO_DATA
; 316  : 		return FALSE;
; 317  : 	}
; 318  : 
; 319  : #ifdef __INTERNALSERVER
; 320  : 	PrintDiag( NULL, SQL_HANDLE_STMT );
; 321  : #endif
; 322  : 
; 323  : 	return FALSE;

  0000c	0f bf c0	 movsx	 eax, ax
  0000f	83 f8 64	 cmp	 eax, 100		; 00000064H
  00012	77 14		 ja	 SHORT $L148136

; 304  : 
; 305  : 	switch( result )

  00014	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L148457[eax]
  0001b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L148458[ecx*4]
$L148139:

; 306  : 	{
; 307  : 	case SQL_SUCCESS_WITH_INFO:
; 308  : 		#ifdef _DEBUG
; 309  : 			PrintDiag( NULL, SQL_HANDLE_STMT );
; 310  : 		#endif
; 311  : 	case SQL_SUCCESS:
; 312  : 	case SQL_NEED_DATA:
; 313  : 		return TRUE;

  00022	b8 01 00 00 00	 mov	 eax, 1

; 324  : }

  00027	c3		 ret	 0
$L148136:

; 314  : 
; 315  : 	case SQL_NO_DATA_FOUND:		// == SQL_NO_DATA
; 316  : 		return FALSE;
; 317  : 	}
; 318  : 
; 319  : #ifdef __INTERNALSERVER
; 320  : 	PrintDiag( NULL, SQL_HANDLE_STMT );
; 321  : #endif
; 322  : 
; 323  : 	return FALSE;

  00028	33 c0		 xor	 eax, eax

; 324  : }

  0002a	c3		 ret	 0
  0002b	90		 npad	 1
$L148458:
  0002c	00 00 00 00	 DD	 $L148139
  00030	00 00 00 00	 DD	 $L148136
  00034	00 00 00 00	 DD	 $L148136
$L148457:
  00038	00		 DB	 0
  00039	00		 DB	 0
  0003a	02		 DB	 2
  0003b	02		 DB	 2
  0003c	02		 DB	 2
  0003d	02		 DB	 2
  0003e	02		 DB	 2
  0003f	02		 DB	 2
  00040	02		 DB	 2
  00041	02		 DB	 2
  00042	02		 DB	 2
  00043	02		 DB	 2
  00044	02		 DB	 2
  00045	02		 DB	 2
  00046	02		 DB	 2
  00047	02		 DB	 2
  00048	02		 DB	 2
  00049	02		 DB	 2
  0004a	02		 DB	 2
  0004b	02		 DB	 2
  0004c	02		 DB	 2
  0004d	02		 DB	 2
  0004e	02		 DB	 2
  0004f	02		 DB	 2
  00050	02		 DB	 2
  00051	02		 DB	 2
  00052	02		 DB	 2
  00053	02		 DB	 2
  00054	02		 DB	 2
  00055	02		 DB	 2
  00056	02		 DB	 2
  00057	02		 DB	 2
  00058	02		 DB	 2
  00059	02		 DB	 2
  0005a	02		 DB	 2
  0005b	02		 DB	 2
  0005c	02		 DB	 2
  0005d	02		 DB	 2
  0005e	02		 DB	 2
  0005f	02		 DB	 2
  00060	02		 DB	 2
  00061	02		 DB	 2
  00062	02		 DB	 2
  00063	02		 DB	 2
  00064	02		 DB	 2
  00065	02		 DB	 2
  00066	02		 DB	 2
  00067	02		 DB	 2
  00068	02		 DB	 2
  00069	02		 DB	 2
  0006a	02		 DB	 2
  0006b	02		 DB	 2
  0006c	02		 DB	 2
  0006d	02		 DB	 2
  0006e	02		 DB	 2
  0006f	02		 DB	 2
  00070	02		 DB	 2
  00071	02		 DB	 2
  00072	02		 DB	 2
  00073	02		 DB	 2
  00074	02		 DB	 2
  00075	02		 DB	 2
  00076	02		 DB	 2
  00077	02		 DB	 2
  00078	02		 DB	 2
  00079	02		 DB	 2
  0007a	02		 DB	 2
  0007b	02		 DB	 2
  0007c	02		 DB	 2
  0007d	02		 DB	 2
  0007e	02		 DB	 2
  0007f	02		 DB	 2
  00080	02		 DB	 2
  00081	02		 DB	 2
  00082	02		 DB	 2
  00083	02		 DB	 2
  00084	02		 DB	 2
  00085	02		 DB	 2
  00086	02		 DB	 2
  00087	02		 DB	 2
  00088	02		 DB	 2
  00089	02		 DB	 2
  0008a	02		 DB	 2
  0008b	02		 DB	 2
  0008c	02		 DB	 2
  0008d	02		 DB	 2
  0008e	02		 DB	 2
  0008f	02		 DB	 2
  00090	02		 DB	 2
  00091	02		 DB	 2
  00092	02		 DB	 2
  00093	02		 DB	 2
  00094	02		 DB	 2
  00095	02		 DB	 2
  00096	02		 DB	 2
  00097	02		 DB	 2
  00098	02		 DB	 2
  00099	02		 DB	 2
  0009a	02		 DB	 2
  0009b	00		 DB	 0
  0009c	01		 DB	 1
?Fetch@CQuery@@QAEHXZ ENDP				; CQuery::Fetch
_TEXT	ENDS
PUBLIC	?Clear@CQuery@@QAEXXZ				; CQuery::Clear
EXTRN	_SQLCloseCursor@4:NEAR
EXTRN	_SQLFreeStmt@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Clear@CQuery@@QAEXXZ
_TEXT	SEGMENT
?Clear@CQuery@@QAEXXZ PROC NEAR				; CQuery::Clear, COMDAT
; _this$ = ecx

; 328  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 329  : 	SQLCloseCursor(hStmt);

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLCloseCursor@4

; 330  : 	SQLFreeStmt(hStmt, SQL_UNBIND);

  0000f	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00015	6a 02		 push	 2
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0001d	5e		 pop	 esi

; 331  : }

  0001e	c3		 ret	 0
?Clear@CQuery@@QAEXXZ ENDP				; CQuery::Clear
_TEXT	ENDS
PUBLIC	?FindCol@CQuery@@AAEHPAD@Z			; CQuery::FindCol
EXTRN	_stricmp:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindCol@CQuery@@AAEHPAD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?FindCol@CQuery@@AAEHPAD@Z PROC NEAR			; CQuery::FindCol, COMDAT
; _this$ = ecx

; 335  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	8b d9		 mov	 ebx, ecx

; 336  : 	int i;
; 337  : 	for (i=0;i<nCol;i++) 

  00005	33 f6		 xor	 esi, esi
  00007	66 39 b3 0c 07
	00 00		 cmp	 WORD PTR [ebx+1804], si
  0000e	57		 push	 edi
  0000f	7e 2c		 jle	 SHORT $L148151
  00011	8b 6c 24 14	 mov	 ebp, DWORD PTR _name$[esp+12]
  00015	8d bb 0e 07 00
	00		 lea	 edi, DWORD PTR [ebx+1806]
  0001b	eb 03 8d 49 00	 npad	 5
$L148149:

; 338  : 	{
; 339  : 		if (stricmp(name,(LPCTSTR)ColName[i])==0)

  00020	57		 push	 edi
  00021	55		 push	 ebp
  00022	e8 00 00 00 00	 call	 _stricmp
  00027	83 c4 08	 add	 esp, 8
  0002a	85 c0		 test	 eax, eax
  0002c	74 19		 je	 SHORT $L148466
  0002e	0f bf 83 0c 07
	00 00		 movsx	 eax, WORD PTR [ebx+1804]
  00035	46		 inc	 esi
  00036	83 c7 32	 add	 edi, 50			; 00000032H
  00039	3b f0		 cmp	 esi, eax
  0003b	7c e3		 jl	 SHORT $L148149
$L148151:
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp

; 341  : 	}
; 342  : 	return -1;

  00040	83 c8 ff	 or	 eax, -1
  00043	5b		 pop	 ebx

; 343  : }

  00044	c2 04 00	 ret	 4
$L148466:
  00047	5f		 pop	 edi

; 340  : 			return i+1;

  00048	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0004b	5e		 pop	 esi
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 343  : }

  0004e	c2 04 00	 ret	 4
?FindCol@CQuery@@AAEHPAD@Z ENDP				; CQuery::FindCol
_TEXT	ENDS
PUBLIC	?GetInt@CQuery@@QAEHH@Z				; CQuery::GetInt
EXTRN	_atoi:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetInt@CQuery@@QAEHH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetInt@CQuery@@QAEHH@Z PROC NEAR			; CQuery::GetInt, COMDAT
; _this$ = ecx

; 348  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 08		 jle	 SHORT $L148158

; 349  : 		return CQUERYNOCOL;

  0000f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 357  : 	}
; 358  : }

  00014	c2 04 00	 ret	 4
$L148158:

; 350  : 
; 351  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00017	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  0001f	75 08		 jne	 SHORT $L148159

; 352  : 	{
; 353  : 		return CQUERYNULL;

  00021	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH

; 357  : 	}
; 358  : }

  00026	c2 04 00	 ret	 4
$L148159:

; 354  : 	} else 
; 355  : 	{
; 356  : 		return atoi(Col[nCol-1]);

  00029	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _atoi
  00036	83 c4 04	 add	 esp, 4

; 357  : 	}
; 358  : }

  00039	c2 04 00	 ret	 4
?GetInt@CQuery@@QAEHH@Z ENDP				; CQuery::GetInt
_TEXT	ENDS
PUBLIC	?GetInt@CQuery@@QAEHPAD@Z			; CQuery::GetInt
; Function compile flags: /Ogty
;	COMDAT ?GetInt@CQuery@@QAEHPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetInt@CQuery@@QAEHPAD@Z PROC NEAR			; CQuery::GetInt, COMDAT
; _this$ = ecx

; 363  : 	int n;
; 364  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 365  : 	if (n==-1) 

  0000d	83 f8 ff	 cmp	 eax, -1

; 366  : 	{
; 367  : 		return CQUERYNOCOL;

  00010	74 0b		 je	 SHORT $L148481

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

  00012	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00019	3b c1		 cmp	 eax, ecx
  0001b	7e 09		 jle	 SHORT $L148476
$L148481:
  0001d	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00022	5e		 pop	 esi

; 371  : 	}
; 372  : }

  00023	c2 04 00	 ret	 4

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

$L148476:
  00026	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  0002e	75 09		 jne	 SHORT $L148477
  00030	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00035	5e		 pop	 esi

; 371  : 	}
; 372  : }

  00036	c2 04 00	 ret	 4

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

$L148477:
  00039	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _atoi
  00046	83 c4 04	 add	 esp, 4
  00049	5e		 pop	 esi

; 371  : 	}
; 372  : }

  0004a	c2 04 00	 ret	 4
?GetInt@CQuery@@QAEHPAD@Z ENDP				; CQuery::GetInt
_TEXT	ENDS
PUBLIC	?GetInt64@CQuery@@QAE_JH@Z			; CQuery::GetInt64
EXTRN	__atoi64:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetInt64@CQuery@@QAE_JH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetInt64@CQuery@@QAE_JH@Z PROC NEAR			; CQuery::GetInt64, COMDAT
; _this$ = ecx

; 377  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 0b		 jle	 SHORT $L148172

; 378  : 		return CQUERYNOCOL;

  0000f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00014	83 ca ff	 or	 edx, -1

; 386  : 	}
; 387  : }

  00017	c2 04 00	 ret	 4
$L148172:
  0001a	56		 push	 esi

; 379  : 
; 380  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  0001b	8b b4 81 0c 39
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+14604]
  00022	83 ca ff	 or	 edx, -1
  00025	3b f2		 cmp	 esi, edx
  00027	5e		 pop	 esi
  00028	75 08		 jne	 SHORT $L148173

; 381  : 	{
; 382  : 		return CQUERYNULL;

  0002a	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH

; 386  : 	}
; 387  : }

  0002f	c2 04 00	 ret	 4
$L148173:

; 383  : 	} else 
; 384  : 	{
; 385  : 		return _atoi64(Col[nCol-1]);

  00032	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 __atoi64
  0003f	83 c4 04	 add	 esp, 4

; 386  : 	}
; 387  : }

  00042	c2 04 00	 ret	 4
?GetInt64@CQuery@@QAE_JH@Z ENDP				; CQuery::GetInt64
_TEXT	ENDS
PUBLIC	?GetInt64@CQuery@@QAE_JPAD@Z			; CQuery::GetInt64
; Function compile flags: /Ogty
;	COMDAT ?GetInt64@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetInt64@CQuery@@QAE_JPAD@Z PROC NEAR			; CQuery::GetInt64, COMDAT
; _this$ = ecx

; 392  : 	int n;
; 393  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 394  : 	if (n==-1) 

  0000d	83 ca ff	 or	 edx, -1
  00010	3b c2		 cmp	 eax, edx

; 395  : 	{
; 396  : 		return CQUERYNOCOL;

  00012	74 0b		 je	 SHORT $L148495

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

  00014	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  0001b	3b c1		 cmp	 eax, ecx
  0001d	7e 09		 jle	 SHORT $L148491
$L148495:
  0001f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00024	5e		 pop	 esi

; 400  : 	}
; 401  : }

  00025	c2 04 00	 ret	 4

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

$L148491:
  00028	39 94 86 0c 39
	00 00		 cmp	 DWORD PTR [esi+eax*4+14604], edx
  0002f	75 09		 jne	 SHORT $L148492
  00031	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00036	5e		 pop	 esi

; 400  : 	}
; 401  : }

  00037	c2 04 00	 ret	 4

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

$L148492:
  0003a	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 __atoi64
  00047	83 c4 04	 add	 esp, 4
  0004a	5e		 pop	 esi

; 400  : 	}
; 401  : }

  0004b	c2 04 00	 ret	 4
?GetInt64@CQuery@@QAE_JPAD@Z ENDP			; CQuery::GetInt64
_TEXT	ENDS
PUBLIC	__real@c2cc0000
PUBLIC	__real@c2c80000
PUBLIC	?GetFloat@CQuery@@QAEMH@Z			; CQuery::GetFloat
EXTRN	__fltused:NEAR
EXTRN	_atof:NEAR
;	COMDAT __real@c2cc0000
CONST	SEGMENT
__real@c2cc0000 DD 0c2cc0000r			; -102
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetFloat@CQuery@@QAEMH@Z PROC NEAR			; CQuery::GetFloat, COMDAT
; _this$ = ecx

; 406  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 09		 jle	 SHORT $L148186

; 407  : 		return CQUERYNOCOL;

  0000f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000

; 415  : 	}
; 416  : }

  00015	c2 04 00	 ret	 4
$L148186:

; 408  : 	
; 409  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00018	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  00020	75 09		 jne	 SHORT $L148187

; 410  : 	{
; 411  : 		return CQUERYNULL;

  00022	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2c80000

; 415  : 	}
; 416  : }

  00028	c2 04 00	 ret	 4
$L148187:

; 412  : 	} else 
; 413  : 	{
; 414  : 		return	( (float)( atof(Col[nCol-1]) ) );

  0002b	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _atof
  00038	83 c4 04	 add	 esp, 4

; 415  : 	}
; 416  : }

  0003b	c2 04 00	 ret	 4
?GetFloat@CQuery@@QAEMH@Z ENDP				; CQuery::GetFloat
_TEXT	ENDS
PUBLIC	?GetFloat@CQuery@@QAEMPAD@Z			; CQuery::GetFloat
; Function compile flags: /Ogty
;	COMDAT ?GetFloat@CQuery@@QAEMPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetFloat@CQuery@@QAEMPAD@Z PROC NEAR			; CQuery::GetFloat, COMDAT
; _this$ = ecx

; 421  : 	int n;
; 422  : 	n = FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 423  : 	if (n==-1)

  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 0a		 jne	 SHORT $L148195

; 424  : 		return CQUERYNOCOL;

  00012	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000
  00018	5e		 pop	 esi

; 427  : }

  00019	c2 04 00	 ret	 4
$L148195:

; 425  : 	else
; 426  : 		return GetFloat(n);

  0001c	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00023	3b c1		 cmp	 eax, ecx
  00025	7e 0a		 jle	 SHORT $L148510
  00027	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000
  0002d	5e		 pop	 esi

; 427  : }

  0002e	c2 04 00	 ret	 4

; 425  : 	else
; 426  : 		return GetFloat(n);

$L148510:
  00031	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  00039	75 0a		 jne	 SHORT $L148511
  0003b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2c80000
  00041	5e		 pop	 esi

; 427  : }

  00042	c2 04 00	 ret	 4

; 425  : 	else
; 426  : 		return GetFloat(n);

$L148511:
  00045	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _atof
  00052	83 c4 04	 add	 esp, 4
  00055	5e		 pop	 esi

; 427  : }

  00056	c2 04 00	 ret	 4
?GetFloat@CQuery@@QAEMPAD@Z ENDP			; CQuery::GetFloat
_TEXT	ENDS
PUBLIC	?GetChar@CQuery@@QAEDH@Z			; CQuery::GetChar
; Function compile flags: /Ogty
;	COMDAT ?GetChar@CQuery@@QAEDH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetChar@CQuery@@QAEDH@Z PROC NEAR			; CQuery::GetChar, COMDAT
; _this$ = ecx

; 432  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 05		 jle	 SHORT $L148201

; 433  : 		return CQUERYNOCOL;

  0000f	b0 9a		 mov	 al, -102		; ffffff9aH

; 441  : 	}
; 442  : }

  00011	c2 04 00	 ret	 4
$L148201:

; 434  : 	
; 435  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00014	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  0001c	75 05		 jne	 SHORT $L148202

; 436  : 	{
; 437  : 		return CQUERYNULL;

  0001e	b0 9c		 mov	 al, -100		; ffffff9cH

; 441  : 	}
; 442  : }

  00020	c2 04 00	 ret	 4
$L148202:

; 438  : 	} else 
; 439  : 	{
; 440  : 		return Col[nCol-1][0];

  00023	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  0002a	8a 00		 mov	 al, BYTE PTR [eax]

; 441  : 	}
; 442  : }

  0002c	c2 04 00	 ret	 4
?GetChar@CQuery@@QAEDH@Z ENDP				; CQuery::GetChar
_TEXT	ENDS
PUBLIC	?GetChar@CQuery@@QAEDPAD@Z			; CQuery::GetChar
; Function compile flags: /Ogty
;	COMDAT ?GetChar@CQuery@@QAEDPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetChar@CQuery@@QAEDPAD@Z PROC NEAR			; CQuery::GetChar, COMDAT
; _this$ = ecx

; 446  : 	int n;
; 447  : 	n = FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 448  : 	if (n==-1)

  0000d	83 f8 ff	 cmp	 eax, -1

; 449  : 		return CQUERYNOCOL;

  00010	74 0b		 je	 SHORT $L148527

; 450  : 	else
; 451  : 		return GetChar(n);

  00012	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00019	3b c1		 cmp	 eax, ecx
  0001b	7e 06		 jle	 SHORT $L148523
$L148527:
  0001d	b0 9a		 mov	 al, -102		; ffffff9aH
  0001f	5e		 pop	 esi

; 452  : }

  00020	c2 04 00	 ret	 4

; 450  : 	else
; 451  : 		return GetChar(n);

$L148523:
  00023	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  0002b	75 06		 jne	 SHORT $L148524
  0002d	b0 9c		 mov	 al, -100		; ffffff9cH
  0002f	5e		 pop	 esi

; 452  : }

  00030	c2 04 00	 ret	 4

; 450  : 	else
; 451  : 		return GetChar(n);

$L148524:
  00033	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  0003a	8a 02		 mov	 al, BYTE PTR [edx]
  0003c	5e		 pop	 esi

; 452  : }

  0003d	c2 04 00	 ret	 4
?GetChar@CQuery@@QAEDPAD@Z ENDP				; CQuery::GetChar
_TEXT	ENDS
PUBLIC	?GetStr@CQuery@@QAEXHPAD@Z			; CQuery::GetStr
PUBLIC	??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@		; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
EXTRN	__imp__lstrcpyA@8:NEAR
;	COMDAT ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
CONST	SEGMENT
??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@ DB 'CQUERYNOCOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXHPAD@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CQuery@@QAEXHPAD@Z PROC NEAR			; CQuery::GetStr, COMDAT
; _this$ = ecx

; 458  : 	if (nCol > this->nCol) 

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 21		 jle	 SHORT $L148216

; 459  : 	{
; 460  : 		strcpy(buf, "CQUERYNOCOL");

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _buf$[esp-4]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@+4
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00024	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@+8
  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 469  : 	}
; 470  : }

  0002d	c2 08 00	 ret	 8
$L148216:

; 461  : 		return;
; 462  : 	}
; 463  : 
; 464  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00030	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1

; 465  : 	{
; 466  : 		lstrcpy(buf,"NULL");

  00038	8b 54 24 08	 mov	 edx, DWORD PTR _buf$[esp-4]
  0003c	75 0f		 jne	 SHORT $L148218
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
  00043	52		 push	 edx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 469  : 	}
; 470  : }

  0004a	c2 08 00	 ret	 8
$L148218:

; 467  : 	} else {
; 468  : 		 strcpy(buf,Col[nCol-1]);

  0004d	8b 8c 81 04 03
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+772]
$L148531:
  00054	8a 01		 mov	 al, BYTE PTR [ecx]
  00056	41		 inc	 ecx
  00057	88 02		 mov	 BYTE PTR [edx], al
  00059	42		 inc	 edx
  0005a	84 c0		 test	 al, al
  0005c	75 f6		 jne	 SHORT $L148531

; 469  : 	}
; 470  : }

  0005e	c2 08 00	 ret	 8
?GetStr@CQuery@@QAEXHPAD@Z ENDP				; CQuery::GetStr
_TEXT	ENDS
PUBLIC	?GetStr@CQuery@@QAEXPAD0@Z			; CQuery::GetStr
PUBLIC	??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@ ; `string'
;	COMDAT ??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@ DB 'ERROR:Colume not fo'
	DB	'und', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXPAD0@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CQuery@@QAEXPAD0@Z PROC NEAR			; CQuery::GetStr, COMDAT
; _this$ = ecx

; 475  : 	int n;
; 476  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 477  : 	if (n==-1) 

  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 14		 jne	 SHORT $L148227

; 478  : 	{
; 479  : 		lstrcpy(buf,"ERROR:Colume not found");

  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR _buf$[esp]
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00022	5e		 pop	 esi

; 483  : 	}
; 484  : }

  00023	c2 08 00	 ret	 8
$L148227:

; 480  : 	} else 
; 481  : 	{
; 482  : 		GetStr(n, buf);

  00026	8b 54 24 0c	 mov	 edx, DWORD PTR _buf$[esp]
  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXHPAD@Z ; CQuery::GetStr
  00033	5e		 pop	 esi

; 483  : 	}
; 484  : }

  00034	c2 08 00	 ret	 8
?GetStr@CQuery@@QAEXPAD0@Z ENDP				; CQuery::GetStr
_TEXT	ENDS
PUBLIC	?WriteBlob@CQuery@@QAEXPBDPAXH@Z		; CQuery::WriteBlob
EXTRN	__chkstk:NEAR
EXTRN	_SQLExecDirect@12:NEAR
EXTRN	_SQLParamData@8:NEAR
EXTRN	_SQLPutData@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?WriteBlob@CQuery@@QAEXPBDPAXH@Z
_TEXT	SEGMENT
tv249 = -10028						; size = 4
_pToken$ = -10024					; size = 4
_this$ = -10020						; size = 4
_cbBlob$ = -10016					; size = 4
$T148549 = -10012					; size = 4
_tmp$ = -10008						; size = 10000
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
?WriteBlob@CQuery@@QAEXPBDPAXH@Z PROC NEAR		; CQuery::WriteBlob, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 2c 27 00 00	 mov	 eax, 10028		; 0000272cH
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 576  : 	SQLINTEGER cbBlob;
; 577  : 	char tmp[BLOBBATCH],*p;
; 578  : 	SQLPOINTER pToken;
; 579  : 	int nPut;
; 580  : 
; 581  : 	cbBlob=SQL_LEN_DATA_AT_EXEC(size);

  00018	8b 7d 10	 mov	 edi, DWORD PTR _size$[ebp]
  0001b	8b f1		 mov	 esi, ecx

; 582  : 	SQLBindParameter(hStmt,1,SQL_PARAM_INPUT,SQL_C_BINARY,SQL_LONGVARBINARY,
; 583  : 		size,0,(SQLPOINTER)1,0,&cbBlob);

  0001d	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  00023	8d 4c 24 18	 lea	 ecx, DWORD PTR _cbBlob$[esp+10040]
  00027	51		 push	 ecx
  00028	6a 00		 push	 0
  0002a	6a 01		 push	 1
  0002c	6a 00		 push	 0
  0002e	57		 push	 edi
  0002f	6a fc		 push	 -4			; fffffffcH
  00031	6a fe		 push	 -2			; fffffffeH
  00033	89 84 24 50 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10068], eax
  0003a	6a 01		 push	 1
  0003c	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00041	6a 01		 push	 1
  00043	2b c7		 sub	 eax, edi
  00045	52		 push	 edx
  00046	89 74 24 3c	 mov	 DWORD PTR _this$[esp+10080], esi
  0004a	89 44 24 40	 mov	 DWORD PTR _cbBlob$[esp+10080], eax
  0004e	e8 00 00 00 00	 call	 _SQLBindParameter@40

; 584  : 	SQLExecDirect(hStmt,(SQLCHAR *)szSQL,SQL_NTS);

  00053	8b 45 08	 mov	 eax, DWORD PTR _szSQL$[ebp]
  00056	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  0005c	6a fd		 push	 -3			; fffffffdH
  0005e	50		 push	 eax
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 585  : 	SQLRETURN ret=SQLParamData(hStmt, &pToken);

  00065	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  0006b	8d 54 24 10	 lea	 edx, DWORD PTR _pToken$[esp+10040]
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _SQLParamData@8

; 586  : 	while (ret==SQL_NEED_DATA) 

  00076	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  0007a	0f 85 97 00 00
	00		 jne	 $L148298
$L148556:

; 587  : 	{
; 588  : 		if (ret==SQL_NEED_DATA) 
; 589  : 		{
; 590  : 			if ((int)pToken==1) 

  00080	83 7c 24 10 01	 cmp	 DWORD PTR _pToken$[esp+10040], 1
  00085	75 75		 jne	 SHORT $L148306

; 591  : 			{
; 592  : 				for (p=(char *)buf;p<(char *)buf+size;p+=BLOBBATCH) 

  00087	8b 5d 0c	 mov	 ebx, DWORD PTR _buf$[ebp]
  0008a	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0008d	3b d8		 cmp	 ebx, eax
  0008f	89 44 24 1c	 mov	 DWORD PTR $T148549[esp+10040], eax
  00093	73 67		 jae	 SHORT $L148306
  00095	8b c7		 mov	 eax, edi
  00097	89 44 24 0c	 mov	 DWORD PTR tv249[esp+10040], eax
  0009b	eb 04		 jmp	 SHORT $L148304
$L148550:
  0009d	8b 44 24 0c	 mov	 eax, DWORD PTR tv249[esp+10040]
$L148304:

; 593  : 				{
; 594  : 					nPut=min(BLOBBATCH,(char *)buf+size-p);

  000a1	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  000a6	7e 05		 jle	 SHORT $L148541
  000a8	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
$L148541:

; 595  : 					memcpy(tmp,p,nPut);

  000ad	8b c8		 mov	 ecx, eax
  000af	8b d1		 mov	 edx, ecx
  000b1	c1 e9 02	 shr	 ecx, 2
  000b4	8b f3		 mov	 esi, ebx
  000b6	8d 7c 24 20	 lea	 edi, DWORD PTR _tmp$[esp+10040]
  000ba	f3 a5		 rep movsd
  000bc	8b ca		 mov	 ecx, edx
  000be	83 e1 03	 and	 ecx, 3

; 596  : 					SQLPutData(hStmt,(PTR)tmp,nPut);

  000c1	50		 push	 eax
  000c2	f3 a4		 rep movsb
  000c4	8b 4c 24 18	 mov	 ecx, DWORD PTR _this$[esp+10044]
  000c8	8b 91 08 07 00
	00		 mov	 edx, DWORD PTR [ecx+1800]
  000ce	8d 44 24 24	 lea	 eax, DWORD PTR _tmp$[esp+10044]
  000d2	50		 push	 eax
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _SQLPutData@12
  000d9	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv249[esp+10040]
  000dd	8b 44 24 1c	 mov	 eax, DWORD PTR $T148549[esp+10040]
  000e1	81 c3 10 27 00
	00		 add	 ebx, 10000		; 00002710H
  000e7	81 e9 10 27 00
	00		 sub	 ecx, 10000		; 00002710H
  000ed	3b d8		 cmp	 ebx, eax
  000ef	89 4c 24 0c	 mov	 DWORD PTR tv249[esp+10040], ecx
  000f3	72 a8		 jb	 SHORT $L148550
  000f5	8b 74 24 14	 mov	 esi, DWORD PTR _this$[esp+10040]
  000f9	8b 7d 10	 mov	 edi, DWORD PTR _size$[ebp]
$L148306:

; 597  : 				}
; 598  : 			}
; 599  : 		}
; 600  : 		ret=SQLParamData(hStmt, &pToken);

  000fc	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00102	8d 44 24 10	 lea	 eax, DWORD PTR _pToken$[esp+10040]
  00106	50		 push	 eax
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 _SQLParamData@8
  0010d	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  00111	0f 84 69 ff ff
	ff		 je	 $L148556
$L148298:

; 601  : 	}
; 602  : 	Clear();

  00117	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00123	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00129	6a 02		 push	 2
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 603  : }

  00131	8b 8c 24 34 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10040]
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 0c 00	 ret	 12			; 0000000cH
?WriteBlob@CQuery@@QAEXPBDPAXH@Z ENDP			; CQuery::WriteBlob
_TEXT	ENDS
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	?WriteLogFile@CQuery@@QAAXPADZZ			; CQuery::WriteLogFile
PUBLIC	??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@ ; `string'
PUBLIC	??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@ ; `string'
EXTRN	__imp__OutputDebugStringA@4:NEAR
EXTRN	__imp__GetLocalTime@4:NEAR
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	__vsnprintf:NEAR
EXTRN	?MakeFileNameDate@@YAPBDPBD@Z:NEAR		; MakeFileNameDate
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
CONST	SEGMENT
??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@ DB '..\CQuery-LogFile.'
	DB	'txt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@ DB '%'
	DB	'd/%02d/%02d', 09H, '%02d:%02d:%02d', 0aH, '%s', 0aH, 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?WriteLogFile@CQuery@@QAAXPADZZ
_TEXT	SEGMENT
_time$ = -65556						; size = 16
_szBuffer$ = -65540					; size = 65536
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?WriteLogFile@CQuery@@QAAXPADZZ PROC NEAR		; CQuery::WriteLogFile, COMDAT

; 606  : {	

  00000	b8 14 00 01 00	 mov	 eax, 65556		; 00010014H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 607  : 	TCHAR szBuffer[1024* 64];
; 608  : 
; 609  : 	va_list args;
; 610  : 	va_start( args, lpszFormat );
; 611  : 	int n = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  0000f	8b 8c 24 1c 00
	01 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+65552]
  00016	89 84 24 10 00
	01 00		 mov	 DWORD PTR __$ArrayPad$[esp+65556], eax
  0001d	8d 84 24 20 00
	01 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+65556]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	8d 54 24 18	 lea	 edx, DWORD PTR _szBuffer$[esp+65564]
  0002a	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 __vsnprintf
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 612  : 	va_end( args );
; 613  : 
; 614  : 	if( n == -1 ) // if the number of bytes to write exceeds buffer, then count bytes are written and -1 is returned

  00038	83 f8 ff	 cmp	 eax, -1
  0003b	74 76		 je	 SHORT $L148314
  0003d	56		 push	 esi

; 615  : 		return;
; 616  : 
; 617  : 	OutputDebugString( szBuffer );

  0003e	8d 44 24 14	 lea	 eax, DWORD PTR _szBuffer$[esp+65560]
  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 618  : 
; 619  : 	FILE* fp = fopen( MakeFileNameDate( "..\\CQuery-LogFile.txt" ), "a" );

  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01MCMALHOG@a?$AA@
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
  00053	e8 00 00 00 00	 call	 ?MakeFileNameDate@@YAPBDPBD@Z ; MakeFileNameDate
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _fopen
  00061	8b f0		 mov	 esi, eax
  00063	83 c4 08	 add	 esp, 8

; 620  : 	if( fp == NULL )

  00066	85 f6		 test	 esi, esi
  00068	74 48		 je	 SHORT $L148561

; 621  : 		return;
; 622  : 
; 623  : 	// time
; 624  : 	SYSTEMTIME	time;
; 625  : 	GetLocalTime( &time );

  0006a	8d 4c 24 04	 lea	 ecx, DWORD PTR _time$[esp+65560]
  0006e	51		 push	 ecx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 626  : 	fprintf( fp, "%d/%02d/%02d\t%02d:%02d:%02d\n%s\n", 
; 627  : 		     time.wYear, time.wMonth, time.wDay, time.wHour, time.wMinute, time.wSecond,
; 628  : 		     szBuffer );

  00075	0f b7 44 24 10	 movzx	 eax, WORD PTR _time$[esp+65572]
  0007a	0f b7 4c 24 0e	 movzx	 ecx, WORD PTR _time$[esp+65570]
  0007f	8d 54 24 14	 lea	 edx, DWORD PTR _szBuffer$[esp+65560]
  00083	52		 push	 edx
  00084	0f b7 54 24 10	 movzx	 edx, WORD PTR _time$[esp+65572]
  00089	50		 push	 eax
  0008a	0f b7 44 24 12	 movzx	 eax, WORD PTR _time$[esp+65574]
  0008f	51		 push	 ecx
  00090	0f b7 4c 24 12	 movzx	 ecx, WORD PTR _time$[esp+65574]
  00095	52		 push	 edx
  00096	0f b7 54 24 14	 movzx	 edx, WORD PTR _time$[esp+65576]
  0009b	50		 push	 eax
  0009c	51		 push	 ecx
  0009d	52		 push	 edx
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
  000a3	56		 push	 esi
  000a4	e8 00 00 00 00	 call	 _fprintf

; 629  : 	fclose( fp );

  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _fclose
  000af	83 c4 28	 add	 esp, 40			; 00000028H
$L148561:
  000b2	5e		 pop	 esi
$L148314:

; 630  : }

  000b3	8b 8c 24 10 00
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+65556]
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	81 c4 14 00 01
	00		 add	 esp, 65556		; 00010014H
  000c5	c3		 ret	 0
?WriteLogFile@CQuery@@QAAXPADZZ ENDP			; CQuery::WriteLogFile
_TEXT	ENDS
PUBLIC	?PrepareFetch@CQuery@@QAEHXZ			; CQuery::PrepareFetch
EXTRN	_SQLBindCol@24:NEAR
EXTRN	_SQLDescribeCol@36:NEAR
EXTRN	_SQLNumResultCols@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?PrepareFetch@CQuery@@QAEHXZ
_TEXT	SEGMENT
_m_nNullability$ = -24					; size = 2
_m_nScale$ = -20					; size = 2
_m_nSQLType$ = -16					; size = 2
_nActualLen$ = -12					; size = 2
tv271 = -8						; size = 4
_m_nPrecision$ = -4					; size = 4
?PrepareFetch@CQuery@@QAEHXZ PROC NEAR			; CQuery::PrepareFetch, COMDAT
; _this$ = ecx

; 634  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b e9		 mov	 ebp, ecx

; 635  : 	SQLNumResultCols(hStmt,&nCol);

  00007	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  0000d	8d b5 0c 07 00
	00		 lea	 esi, DWORD PTR [ebp+1804]
  00013	56		 push	 esi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _SQLNumResultCols@8

; 636  : 	if (nCol > MAXCOL)

  0001a	66 8b 06	 mov	 ax, WORD PTR [esi]
  0001d	66 3d 00 01	 cmp	 ax, 256			; 00000100H
  00021	7e 08		 jle	 SHORT $L148332
  00023	5e		 pop	 esi

; 637  : 		return FALSE;

  00024	33 c0		 xor	 eax, eax
  00026	5d		 pop	 ebp

; 668  : }

  00027	83 c4 18	 add	 esp, 24			; 00000018H
  0002a	c3		 ret	 0
$L148332:

; 638  : 	
; 639  : 	// nCol 0  Select      
; 640  : 	//    .
; 641  : 	if (nCol == 0) 

  0002b	66 85 c0	 test	 ax, ax
  0002e	75 25		 jne	 SHORT $L148333

; 642  : 	{
; 643  : 		Clear();

  00030	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  0003c	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  00042	6a 02		 push	 2
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0004a	5e		 pop	 esi

; 665  : 	}
; 666  : 
; 667  : 	return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	5d		 pop	 ebp

; 668  : }

  00051	83 c4 18	 add	 esp, 24			; 00000018H
  00054	c3		 ret	 0
$L148333:
  00055	57		 push	 edi

; 644  : 		return TRUE;
; 645  : 	}
; 646  : 	
; 647  : 	SWORD	nActualLen;
; 648  : 	SWORD	m_nSQLType;
; 649  : 	UDWORD	m_nPrecision;
; 650  : 	SWORD	m_nScale;
; 651  : 	SWORD	m_nNullability;
; 652  :  
; 653  : 	//     . Col zero base, 
; 654  : 	//   one base  
; 655  : 	for (int c=0;c<nCol;c++) 

  00056	33 ff		 xor	 edi, edi
  00058	66 85 c0	 test	 ax, ax
  0005b	7e 7c		 jle	 SHORT $L148342
  0005d	8d 85 0e 07 00
	00		 lea	 eax, DWORD PTR [ebp+1806]
  00063	89 44 24 1c	 mov	 DWORD PTR tv271[esp+36], eax
  00067	8d b5 08 03 00
	00		 lea	 esi, DWORD PTR [ebp+776]
  0006d	53		 push	 ebx
  0006e	8b ff		 npad	 2
$L148340:

; 656  : 	{
; 657  : 		SQLBindCol(hStmt,c+1,SQL_C_CHAR,Col[c],8192,&lCol[c]);

  00070	8b 16		 mov	 edx, DWORD PTR [esi]
  00072	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  00078	8d 8e 08 36 00
	00		 lea	 ecx, DWORD PTR [esi+13832]
  0007e	51		 push	 ecx
  0007f	68 00 20 00 00	 push	 8192			; 00002000H
  00084	52		 push	 edx
  00085	6a 01		 push	 1
  00087	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  0008a	53		 push	 ebx
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _SQLBindCol@24

; 658  : 	//	SQLDescribeCol(hStmt,c+1,ColName[c],30,NULL,NULL,NULL,NULL,NULL);
; 659  : 		SQLDescribeCol(hStmt,c+1,ColName[c],30,
; 660  : 			&nActualLen,
; 661  : 			&m_nSQLType,
; 662  : 			&m_nPrecision,
; 663  : 			&m_nScale,
; 664  : 			&m_nNullability);

  00091	8d 4c 24 10	 lea	 ecx, DWORD PTR _m_nNullability$[esp+40]
  00095	51		 push	 ecx
  00096	8d 54 24 18	 lea	 edx, DWORD PTR _m_nScale$[esp+44]
  0009a	52		 push	 edx
  0009b	8d 44 24 2c	 lea	 eax, DWORD PTR _m_nPrecision$[esp+48]
  0009f	50		 push	 eax
  000a0	8b 44 24 2c	 mov	 eax, DWORD PTR tv271[esp+52]
  000a4	8d 4c 24 24	 lea	 ecx, DWORD PTR _m_nSQLType$[esp+52]
  000a8	51		 push	 ecx
  000a9	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  000af	8d 54 24 2c	 lea	 edx, DWORD PTR _nActualLen$[esp+56]
  000b3	52		 push	 edx
  000b4	6a 1e		 push	 30			; 0000001eH
  000b6	50		 push	 eax
  000b7	53		 push	 ebx
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _SQLDescribeCol@36
  000be	8b 4c 24 20	 mov	 ecx, DWORD PTR tv271[esp+40]
  000c2	0f bf 95 0c 07
	00 00		 movsx	 edx, WORD PTR [ebp+1804]
  000c9	47		 inc	 edi
  000ca	83 c1 32	 add	 ecx, 50			; 00000032H
  000cd	83 c6 04	 add	 esi, 4
  000d0	3b fa		 cmp	 edi, edx
  000d2	89 4c 24 20	 mov	 DWORD PTR tv271[esp+40], ecx
  000d6	7c 98		 jl	 SHORT $L148340
  000d8	5b		 pop	 ebx
$L148342:
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 665  : 	}
; 666  : 
; 667  : 	return TRUE;

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	5d		 pop	 ebp

; 668  : }

  000e1	83 c4 18	 add	 esp, 24			; 00000018H
  000e4	c3		 ret	 0
?PrepareFetch@CQuery@@QAEHXZ ENDP			; CQuery::PrepareFetch
_TEXT	ENDS
PUBLIC	?PrintDiag@CQuery@@QAEXPBDF@Z			; CQuery::PrintDiag
PUBLIC	??_C@_05OAGAMKLF@00000?$AA@			; `string'
PUBLIC	??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ ; `string'
EXTRN	__imp__lstrcmpA@8:NEAR
EXTRN	_SQLGetDiagRec@32:NEAR
;	COMDAT ??_C@_05OAGAMKLF@00000?$AA@
CONST	SEGMENT
??_C@_05OAGAMKLF@00000?$AA@ DB '00000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT
??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ DB 'q'
	DB	'uery:%s', 0aH, 'SQLSTATE:%s error:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ DB 'SQLSTATE:%s err'
	DB	'or:%s', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?PrintDiag@CQuery@@QAEXPBDF@Z
_TEXT	SEGMENT
_nLen$ = -532						; size = 2
_nError$ = -528						; size = 4
_szState$ = -524					; size = 6
_szMsg$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_type$ = 12						; size = 2
?PrintDiag@CQuery@@QAEXPBDF@Z PROC NEAR			; CQuery::PrintDiag, COMDAT
; _this$ = ecx

; 488  : {

  00000	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	53		 push	 ebx
  0000c	55		 push	 ebp

; 489  : 
; 490  : /*
; 491  : 	SQLINTEGER NativeError;
; 492  : 	SQLCHAR SqlState[6], Msg[1024];
; 493  : 	SQLSMALLINT MsgLen;
; 494  : 
; 495  : 	int ii=1;
; 496  : 	SQLRETURN Ret = SQLGetDiagRec(SQL_HANDLE_STMT, hStmt, ii, SqlState, &NativeError, Msg, sizeof(Msg), &MsgLen);
; 497  : 	if( Ret != SQL_NO_DATA )
; 498  : 	{
; 499  : 		if( szSQL )
; 500  : 			WriteLogFile("query:%s\nSQLSTATE:%s error:%s", szSQL, (LPCTSTR)SqlState,(LPCTSTR)Msg );
; 501  : 		else
; 502  : 			WriteLogFile("SQLSTATE:%s error:%s", (LPCTSTR)SqlState,(LPCTSTR)Msg );
; 503  : 	}
; 504  : */
; 505  : 	UCHAR szMsg[SQL_MAX_MESSAGE_LENGTH];
; 506  : 	UCHAR szState[SQL_SQLSTATE_SIZE+1];
; 507  : 	SQLSMALLINT nLen;
; 508  : 	SQLINTEGER nError;
; 509  : 	SQLRETURN ret;
; 510  : 
; 511  : 	SQLHANDLE handle = hDbc;
; 512  : 	if( type == SQL_HANDLE_STMT )

  0000d	8b ac 24 24 02
	00 00		 mov	 ebp, DWORD PTR _type$[esp+536]
  00014	66 83 fd 03	 cmp	 bp, 3
  00018	56		 push	 esi
  00019	8b d9		 mov	 ebx, ecx
  0001b	57		 push	 edi
  0001c	8b bb 04 03 00
	00		 mov	 edi, DWORD PTR [ebx+772]
  00022	89 84 24 20 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+548], eax
  00029	75 06		 jne	 SHORT $L148241

; 513  : 		handle = hStmt;

  0002b	8b bb 08 07 00
	00		 mov	 edi, DWORD PTR [ebx+1800]
$L148241:

; 514  : 
; 515  : 	int nIndex=1;

  00031	be 01 00 00 00	 mov	 esi, 1
$L148244:

; 516  : 	while( TRUE )
; 517  : 	{
; 518  : 		ret = SQLGetDiagRec( type, handle, nIndex, szState, &nError, szMsg, SQL_MAX_MESSAGE_LENGTH-1, &nLen );

  00036	8d 44 24 10	 lea	 eax, DWORD PTR _nLen$[esp+548]
  0003a	50		 push	 eax
  0003b	68 ff 01 00 00	 push	 511			; 000001ffH
  00040	8d 4c 24 28	 lea	 ecx, DWORD PTR _szMsg$[esp+556]
  00044	51		 push	 ecx
  00045	8d 54 24 20	 lea	 edx, DWORD PTR _nError$[esp+560]
  00049	52		 push	 edx
  0004a	8d 44 24 28	 lea	 eax, DWORD PTR _szState$[esp+564]
  0004e	50		 push	 eax
  0004f	56		 push	 esi
  00050	57		 push	 edi
  00051	55		 push	 ebp
  00052	e8 00 00 00 00	 call	 _SQLGetDiagRec@32

; 519  : 		if( (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO) &&	lstrcmp((LPCTSTR)szState, "00000") != 0 )

  00057	66 85 c0	 test	 ax, ax
  0005a	74 06		 je	 SHORT $L148248
  0005c	66 3d 01 00	 cmp	 ax, 1
  00060	75 51		 jne	 SHORT $L148247
$L148248:
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05OAGAMKLF@00000?$AA@
  00067	8d 4c 24 1c	 lea	 ecx, DWORD PTR _szState$[esp+552]
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpA@8
  00072	85 c0		 test	 eax, eax
  00074	74 3d		 je	 SHORT $L148247

; 520  : 		{
; 521  : 			if( szSQL )

  00076	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR _szSQL$[esp+544]
  0007d	85 c0		 test	 eax, eax

; 522  : 				WriteLogFile("query:%s\nSQLSTATE:%s error:%s", szSQL, (LPCTSTR)szState,(LPCTSTR)szMsg );

  0007f	8d 54 24 20	 lea	 edx, DWORD PTR _szMsg$[esp+548]
  00083	52		 push	 edx
  00084	74 17		 je	 SHORT $L148250
  00086	8d 4c 24 1c	 lea	 ecx, DWORD PTR _szState$[esp+552]
  0008a	51		 push	 ecx
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
  00091	53		 push	 ebx
  00092	e8 00 00 00 00	 call	 ?WriteLogFile@CQuery@@QAAXPADZZ ; CQuery::WriteLogFile
  00097	83 c4 14	 add	 esp, 20			; 00000014H

; 525  : 			nIndex++;

  0009a	46		 inc	 esi

; 526  : 		}
; 527  : 		else
; 528  : 			break;	
; 529  : 	}

  0009b	eb 99		 jmp	 SHORT $L148244
$L148250:

; 523  : 			else
; 524  : 				WriteLogFile("SQLSTATE:%s error:%s", (LPCTSTR)szState,(LPCTSTR)szMsg );

  0009d	8d 44 24 1c	 lea	 eax, DWORD PTR _szState$[esp+552]
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
  000a7	53		 push	 ebx
  000a8	e8 00 00 00 00	 call	 ?WriteLogFile@CQuery@@QAAXPADZZ ; CQuery::WriteLogFile
  000ad	83 c4 10	 add	 esp, 16			; 00000010H

; 525  : 			nIndex++;

  000b0	46		 inc	 esi

; 526  : 		}
; 527  : 		else
; 528  : 			break;	
; 529  : 	}

  000b1	eb 83		 jmp	 SHORT $L148244
$L148247:

; 530  : }

  000b3	8b 8c 24 20 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+548]
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5d		 pop	 ebp
  000bd	5b		 pop	 ebx
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	81 c4 14 02 00
	00		 add	 esp, 532		; 00000214H
  000c9	c2 08 00	 ret	 8
?PrintDiag@CQuery@@QAEXPBDF@Z ENDP			; CQuery::PrintDiag
_TEXT	ENDS
PUBLIC	?ReadBlob@CQuery@@QAEHPBDPAX@Z			; CQuery::ReadBlob
EXTRN	_SQLGetData@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ReadBlob@CQuery@@QAEHPBDPAX@Z
_TEXT	SEGMENT
_TotalGet$ = -10012					; size = 4
_LenBin$ = -10008					; size = 4
_BinaryPtr$ = -10004					; size = 10000
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_buf$ = 12						; size = 4
?ReadBlob@CQuery@@QAEHPBDPAX@Z PROC NEAR		; CQuery::ReadBlob, COMDAT
; _this$ = ecx

; 536  : {

  00000	b8 1c 27 00 00	 mov	 eax, 10012		; 0000271cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	55		 push	 ebp
  00010	56		 push	 esi

; 537  : 	SQLCHAR BinaryPtr[BLOBBATCH];
; 538  : 	SQLINTEGER LenBin;
; 539  : 	char *p;
; 540  : 	int nGet;
; 541  : 	int TotalGet=0;
; 542  : 
; 543  : 	SQLRETURN ret=SQLExecDirect(hStmt,(SQLCHAR *)szSQL,SQL_NTS);

  00011	8b b4 24 28 27
	00 00		 mov	 esi, DWORD PTR _szSQL$[esp+10016]
  00018	6a fd		 push	 -3			; fffffffdH
  0001a	8b e9		 mov	 ebp, ecx
  0001c	89 84 24 24 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10024], eax
  00023	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  00029	56		 push	 esi
  0002a	50		 push	 eax
  0002b	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _TotalGet$[esp+10032], 0
  00033	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 544  : 	if (ret!=SQL_SUCCESS) {

  00038	66 85 c0	 test	 ax, ax
  0003b	74 24		 je	 SHORT $L148587

; 545  : 		PrintDiag( szSQL );

  0003d	6a 02		 push	 2
  0003f	56		 push	 esi
  00040	8b cd		 mov	 ecx, ebp
  00042	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag
  00047	5e		 pop	 esi

; 546  : 		return -1;

  00048	83 c8 ff	 or	 eax, -1
  0004b	5d		 pop	 ebp

; 570  : }

  0004c	8b 8c 24 18 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10012]
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	81 c4 1c 27 00
	00		 add	 esp, 10012		; 0000271cH
  0005e	c2 08 00	 ret	 8
$L148587:

; 547  : 	}
; 548  : 
; 549  : 	while ((ret=SQLFetch(hStmt)) != SQL_NO_DATA) 

  00061	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00067	53		 push	 ebx
  00068	57		 push	 edi
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _SQLFetch@4
  0006f	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  00073	0f 84 ad 00 00
	00		 je	 $L148274
  00079	8d a4 24 00 00
	00 00		 npad	 7
$L148273:

; 550  : 	{
; 551  : 		p=(char *)buf;
; 552  : 		while ((ret=SQLGetData(hStmt,1,SQL_C_BINARY,BinaryPtr,sizeof(BinaryPtr),
; 553  : 			&LenBin))!=SQL_NO_DATA) {

  00080	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00086	8b 9c 24 34 27
	00 00		 mov	 ebx, DWORD PTR _buf$[esp+10024]
  0008d	8d 54 24 14	 lea	 edx, DWORD PTR _LenBin$[esp+10028]
  00091	52		 push	 edx
  00092	68 10 27 00 00	 push	 10000			; 00002710H
  00097	8d 44 24 20	 lea	 eax, DWORD PTR _BinaryPtr$[esp+10036]
  0009b	50		 push	 eax
  0009c	6a fe		 push	 -2			; fffffffeH
  0009e	6a 01		 push	 1
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _SQLGetData@24
  000a6	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  000aa	74 64		 je	 SHORT $L148278
  000ac	8d 64 24 00	 npad	 4
$L148277:

; 554  : 			if (LenBin==SQL_NULL_DATA) 

  000b0	8b 4c 24 14	 mov	 ecx, DWORD PTR _LenBin$[esp+10028]
  000b4	83 f9 ff	 cmp	 ecx, -1
  000b7	0f 84 a0 00 00
	00		 je	 $L148589

; 558  : 			}
; 559  : 			if (ret==SQL_SUCCESS)

  000bd	66 85 c0	 test	 ax, ax

; 560  : 				nGet=LenBin;

  000c0	8b c1		 mov	 eax, ecx
  000c2	74 05		 je	 SHORT $L148281

; 561  : 			else
; 562  : 				nGet=BLOBBATCH;

  000c4	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
$L148281:

; 563  : 			TotalGet+=nGet;

  000c9	8b 74 24 10	 mov	 esi, DWORD PTR _TotalGet$[esp+10028]
  000cd	03 f0		 add	 esi, eax

; 564  : 			memcpy(p,BinaryPtr,nGet);

  000cf	8b c8		 mov	 ecx, eax
  000d1	8b d1		 mov	 edx, ecx
  000d3	c1 e9 02	 shr	 ecx, 2
  000d6	89 74 24 10	 mov	 DWORD PTR _TotalGet$[esp+10028], esi
  000da	8b fb		 mov	 edi, ebx
  000dc	8d 74 24 18	 lea	 esi, DWORD PTR _BinaryPtr$[esp+10028]
  000e0	f3 a5		 rep movsd
  000e2	8b ca		 mov	 ecx, edx

; 565  : 			p+=nGet;

  000e4	03 d8		 add	 ebx, eax
  000e6	83 e1 03	 and	 ecx, 3
  000e9	8d 44 24 14	 lea	 eax, DWORD PTR _LenBin$[esp+10028]
  000ed	50		 push	 eax
  000ee	68 10 27 00 00	 push	 10000			; 00002710H
  000f3	f3 a4		 rep movsb
  000f5	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  000fb	8d 4c 24 20	 lea	 ecx, DWORD PTR _BinaryPtr$[esp+10036]
  000ff	51		 push	 ecx
  00100	6a fe		 push	 -2			; fffffffeH
  00102	6a 01		 push	 1
  00104	52		 push	 edx
  00105	e8 00 00 00 00	 call	 _SQLGetData@24
  0010a	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  0010e	75 a0		 jne	 SHORT $L148277
$L148278:

; 547  : 	}
; 548  : 
; 549  : 	while ((ret=SQLFetch(hStmt)) != SQL_NO_DATA) 

  00110	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _SQLFetch@4
  0011c	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  00120	0f 85 5a ff ff
	ff		 jne	 $L148273
$L148274:

; 566  : 		}
; 567  : 	}
; 568  : 	Clear();

  00126	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00132	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00138	6a 02		 push	 2
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 569  : 	return TotalGet;

  00140	8b 44 24 10	 mov	 eax, DWORD PTR _TotalGet$[esp+10028]
$L148593:

; 570  : }

  00144	8b 8c 24 28 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10028]
  0014b	5f		 pop	 edi
  0014c	5b		 pop	 ebx
  0014d	5e		 pop	 esi
  0014e	5d		 pop	 ebp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	81 c4 1c 27 00
	00		 add	 esp, 10012		; 0000271cH
  0015a	c2 08 00	 ret	 8
$L148589:

; 555  : 			{
; 556  : 				Clear();

  0015d	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00169	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  0016f	6a 02		 push	 2
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 557  : 				return 0;

  00177	33 c0		 xor	 eax, eax
  00179	eb c9		 jmp	 SHORT $L148593
?ReadBlob@CQuery@@QAEHPBDPAX@Z ENDP			; CQuery::ReadBlob
_TEXT	ENDS
PUBLIC	?Connect@CQuery@@QAEHHPAD0PBD@Z			; CQuery::Connect
PUBLIC	??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@ ; `string'
PUBLIC	??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@		; `string'
EXTRN	__imp__wsprintfA:NEAR
EXTRN	_SQLAllocHandle@12:NEAR
EXTRN	_SQLConnect@28:NEAR
EXTRN	_SQLDriverConnect@32:NEAR
;	COMDAT ??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@ DB 'FileDsn=%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
CONST	SEGMENT
??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@ DB 'DRIVER='
	DB	'{Microsoft Access Driver (*.mdb)};DBQ=%s;', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Connect@CQuery@@QAEHHPAD0PBD@Z
_TEXT	SEGMENT
_ret$ = -520						; size = 2
_cbOutCon$ = -520					; size = 2
_InCon$ = -516						; size = 255
_OutCon$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_Type$ = 8						; size = 4
_ConStr$ = 12						; size = 4
_UID$ = 16						; size = 4
_PWD$ = 20						; size = 4
?Connect@CQuery@@QAEHHPAD0PBD@Z PROC NEAR		; CQuery::Connect, COMDAT
; _this$ = ecx

; 137  : {

  00000	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	53		 push	 ebx
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 84 24 08 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+524], eax

; 138  : 	strcpy( DBName, ConStr );

  00015	8b 84 24 14 02
	00 00		 mov	 eax, DWORD PTR _ConStr$[esp+520]
  0001c	56		 push	 esi
  0001d	8b d3		 mov	 edx, ebx
  0001f	57		 push	 edi
  00020	2b d0		 sub	 edx, eax
$L148599:
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00027	40		 inc	 eax
  00028	84 c9		 test	 cl, cl
  0002a	75 f6		 jne	 SHORT $L148599

; 139  : 	strcpy( DBId, UID );

  0002c	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR _UID$[esp+528]
  00033	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [ebx+256]
  00039	2b d0		 sub	 edx, eax
  0003b	eb 03 8d 49 00	 npad	 5
$L148600:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00045	40		 inc	 eax
  00046	84 c9		 test	 cl, cl
  00048	75 f6		 jne	 SHORT $L148600
  0004a	55		 push	 ebp

; 140  : 	strcpy( DBPass, PWD );

  0004b	8b ac 24 28 02
	00 00		 mov	 ebp, DWORD PTR _PWD$[esp+532]
  00052	8d 93 00 02 00
	00		 lea	 edx, DWORD PTR [ebx+512]
  00058	8b c5		 mov	 eax, ebp
  0005a	2b d5		 sub	 edx, ebp
  0005c	8d 64 24 00	 npad	 4
$L148601:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00065	40		 inc	 eax
  00066	84 c9		 test	 cl, cl
  00068	75 f6		 jne	 SHORT $L148601

; 141  : 	
; 142  : 	SQLCHAR InCon[255];
; 143  : 	SQLCHAR OutCon[255];
; 144  :     SQLSMALLINT cbOutCon;
; 145  : 
; 146  : 	SQLRETURN ret;
; 147  : 
; 148  : 	//      .
; 149  : 	SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&hEnv);

  0006a	8d bb 00 03 00
	00		 lea	 edi, DWORD PTR [ebx+768]
  00070	57		 push	 edi
  00071	6a 00		 push	 0
  00073	6a 01		 push	 1
  00075	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 150  : 	SQLSetEnvAttr(hEnv,SQL_ATTR_ODBC_VERSION,(SQLPOINTER)SQL_OV_ODBC3,SQL_IS_INTEGER);

  0007a	8b 07		 mov	 eax, DWORD PTR [edi]
  0007c	6a fa		 push	 -6			; fffffffaH
  0007e	6a 03		 push	 3
  00080	68 c8 00 00 00	 push	 200			; 000000c8H
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16

; 151  : 	
; 152  : 	//    MDB  SQL ,  DSN .
; 153  : 	SQLAllocHandle(SQL_HANDLE_DBC,hEnv,&hDbc);

  0008b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008d	8d b3 04 03 00
	00		 lea	 esi, DWORD PTR [ebx+772]
  00093	56		 push	 esi
  00094	51		 push	 ecx
  00095	6a 02		 push	 2
  00097	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 154  : 	switch (Type) 

  0009c	8b 84 24 1c 02
	00 00		 mov	 eax, DWORD PTR _Type$[esp+532]
  000a3	48		 dec	 eax
  000a4	74 36		 je	 SHORT $L148056
  000a6	48		 dec	 eax
  000a7	74 24		 je	 SHORT $L148060
  000a9	48		 dec	 eax
  000aa	75 75		 jne	 SHORT $L148605

; 166  : 	case 3:
; 167  : 		ret=SQLConnect(hDbc,(SQLCHAR *)ConStr,SQL_NTS,(SQLCHAR *)UID,SQL_NTS,
; 168  : 			(SQLCHAR *)PWD,SQL_NTS);

  000ac	8b 94 24 24 02
	00 00		 mov	 edx, DWORD PTR _UID$[esp+532]
  000b3	8b 84 24 20 02
	00 00		 mov	 eax, DWORD PTR _ConStr$[esp+532]
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	6a fd		 push	 -3			; fffffffdH
  000be	55		 push	 ebp
  000bf	6a fd		 push	 -3			; fffffffdH
  000c1	52		 push	 edx
  000c2	6a fd		 push	 -3			; fffffffdH
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 _SQLConnect@28

; 169  : 		break;

  000cb	eb 58		 jmp	 SHORT $L148053
$L148060:

; 160  : 		break;
; 161  : 	case 2:
; 162  : 		wsprintf((char *)InCon, "FileDsn=%s",ConStr);

  000cd	8b 94 24 20 02
	00 00		 mov	 edx, DWORD PTR _ConStr$[esp+532]
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@

; 163  : 		ret=SQLDriverConnect(hDbc,NULL,(SQLCHAR *)InCon,sizeof(InCon),OutCon,
; 164  : 			sizeof(OutCon),&cbOutCon, SQL_DRIVER_NOPROMPT);
; 165  : 		break;

  000da	eb 0d		 jmp	 SHORT $L148609
$L148056:

; 155  : 	{
; 156  : 	case 1:
; 157  : 		wsprintf((char *)InCon,"DRIVER={Microsoft Access Driver (*.mdb)};DBQ=%s;",ConStr);

  000dc	8b 94 24 20 02
	00 00		 mov	 edx, DWORD PTR _ConStr$[esp+532]
  000e3	52		 push	 edx
  000e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
$L148609:
  000e9	8d 44 24 1c	 lea	 eax, DWORD PTR _InCon$[esp+544]
  000ed	50		 push	 eax
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 		ret=SQLDriverConnect(hDbc,NULL,(SQLCHAR *)InCon,sizeof(InCon),OutCon,
; 159  : 			sizeof(OutCon),&cbOutCon, SQL_DRIVER_NOPROMPT);

  000f7	6a 00		 push	 0
  000f9	8d 4c 24 14	 lea	 ecx, DWORD PTR _cbOutCon$[esp+540]
  000fd	51		 push	 ecx
  000fe	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00100	68 ff 00 00 00	 push	 255			; 000000ffH
  00105	8d 94 24 20 01
	00 00		 lea	 edx, DWORD PTR _OutCon$[esp+548]
  0010c	52		 push	 edx
  0010d	68 ff 00 00 00	 push	 255			; 000000ffH
  00112	8d 44 24 28	 lea	 eax, DWORD PTR _InCon$[esp+556]
  00116	50		 push	 eax
  00117	6a 00		 push	 0
  00119	51		 push	 ecx
  0011a	e8 00 00 00 00	 call	 _SQLDriverConnect@32
  0011f	eb 04		 jmp	 SHORT $L148053
$L148605:
  00121	8b 44 24 10	 mov	 eax, DWORD PTR _ret$[esp+536]
$L148053:

; 170  : 	}
; 171  : 
; 172  : 	if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO)) 

  00125	66 85 c0	 test	 ax, ax
  00128	5d		 pop	 ebp
  00129	74 31		 je	 SHORT $L148606
  0012b	66 3d 01 00	 cmp	 ax, 1
  0012f	74 2b		 je	 SHORT $L148606

; 173  : 	{
; 174  : 		PrintDiag( ConStr );

  00131	8b 94 24 1c 02
	00 00		 mov	 edx, DWORD PTR _ConStr$[esp+528]
  00138	6a 02		 push	 2
  0013a	52		 push	 edx
  0013b	8b cb		 mov	 ecx, ebx
  0013d	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi

; 175  : 		return FALSE;

  00144	33 c0		 xor	 eax, eax
  00146	5b		 pop	 ebx

; 185  : 	}
; 186  : 
; 187  : //	::SQLSetStmtOption(hStmt, SQL_QUERY_TIMEOUT, 10);  // 10  
; 188  : 	return TRUE;
; 189  : }

  00147	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+520]
  0014e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00153	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  00159	c2 10 00	 ret	 16			; 00000010H
$L148606:

; 176  : 	}
; 177  : 
; 178  : 	//   .
; 179  : 	ret=SQLAllocHandle(SQL_HANDLE_STMT,hDbc,&hStmt);

  0015c	8b 06		 mov	 eax, DWORD PTR [esi]
  0015e	8d bb 08 07 00
	00		 lea	 edi, DWORD PTR [ebx+1800]
  00164	57		 push	 edi
  00165	50		 push	 eax
  00166	6a 03		 push	 3
  00168	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 180  : 	if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO)) 

  0016d	66 85 c0	 test	 ax, ax
  00170	74 37		 je	 SHORT $L148607
  00172	66 3d 01 00	 cmp	 ax, 1
  00176	74 31		 je	 SHORT $L148607

; 181  : 	{
; 182  : 		PrintDiag( ConStr );

  00178	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR _ConStr$[esp+528]
  0017f	6a 02		 push	 2
  00181	51		 push	 ecx
  00182	8b cb		 mov	 ecx, ebx
  00184	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 183  : 		hStmt=0;

  00189	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi

; 184  : 		return FALSE;

  00191	33 c0		 xor	 eax, eax
  00193	5b		 pop	 ebx

; 185  : 	}
; 186  : 
; 187  : //	::SQLSetStmtOption(hStmt, SQL_QUERY_TIMEOUT, 10);  // 10  
; 188  : 	return TRUE;
; 189  : }

  00194	8b 8c 24 04 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+520]
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  001a6	c2 10 00	 ret	 16			; 00000010H
$L148607:
  001a9	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+532]
  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	5b		 pop	 ebx
  001b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bd	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  001c3	c2 10 00	 ret	 16			; 00000010H
?Connect@CQuery@@QAEHHPAD0PBD@Z ENDP			; CQuery::Connect
_TEXT	ENDS
PUBLIC	?Exec@CQuery@@QAEHPBD@Z				; CQuery::Exec
EXTRN	__imp__lstrlenA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Exec@CQuery@@QAEHPBD@Z
_TEXT	SEGMENT
_szSQL$ = 8						; size = 4
?Exec@CQuery@@QAEHPBD@Z PROC NEAR			; CQuery::Exec, COMDAT
; _this$ = ecx

; 216  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 217  : 	Clear();	//       .

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00010	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00016	6a 02		 push	 2
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 218  : 
; 219  : 	SQLRETURN ret = SQLExecDirect( hStmt, (SQLCHAR*)szSQL, lstrlen( szSQL ) );

  0001e	8b 7c 24 0c	 mov	 edi, DWORD PTR _szSQL$[esp+4]
  00022	57		 push	 edi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00029	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 220  : 	switch( ret )

  00037	0f bf c0	 movsx	 eax, ax
  0003a	85 c0		 test	 eax, eax
  0003c	7c 0a		 jl	 SHORT $L148097
  0003e	83 f8 01	 cmp	 eax, 1
  00041	7e 52		 jle	 SHORT $L148100
  00043	83 f8 64	 cmp	 eax, 100		; 00000064H

; 221  : 	{
; 222  : 	case SQL_SUCCESS_WITH_INFO:
; 223  : #ifdef _DEBUG
; 224  : 		PrintDiag( szSQL, SQL_HANDLE_STMT );	
; 225  : #endif
; 226  : 		//    
; 227  : 	case SQL_SUCCESS:
; 228  : 	case SQL_NO_DATA_FOUND:
; 229  : 		break;

  00046	74 4d		 je	 SHORT $L148100
$L148097:

; 230  : 	default:
; 231  : 		{
; 232  : 			PrintDiag( szSQL, SQL_HANDLE_STMT );	

  00048	6a 03		 push	 3
  0004a	57		 push	 edi
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 233  : 			DisConnect();

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?DisConnect@CQuery@@QAEXXZ ; CQuery::DisConnect

; 234  : 			if( Connect( 3, DBName, DBId, DBPass ) )

  00059	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0005f	50		 push	 eax
  00060	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	6a 03		 push	 3
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  00071	85 c0		 test	 eax, eax
  00073	74 2c		 je	 SHORT $L148098

; 235  : 			{
; 236  : 				ret = SQLExecDirect( hStmt, (SQLCHAR *)szSQL, SQL_NTS );

  00075	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0007b	6a fd		 push	 -3			; fffffffdH
  0007d	57		 push	 edi
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 237  : 				if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO) && (ret != SQL_NO_DATA)) 

  00084	66 85 c0	 test	 ax, ax
  00087	74 0c		 je	 SHORT $L148100
  00089	66 3d 01 00	 cmp	 ax, 1
  0008d	74 06		 je	 SHORT $L148100
  0008f	66 3d 64 00	 cmp	 ax, 100			; 00000064H

; 238  : 					return FALSE;

  00093	75 0c		 jne	 SHORT $L148098
$L148100:

; 242  : 		}
; 243  : 	}
; 244  : 
; 245  : 	return PrepareFetch();

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 246  : }

  0009e	c2 04 00	 ret	 4
$L148098:
  000a1	5f		 pop	 edi

; 239  : 			}
; 240  : 			else
; 241  : 				return FALSE;

  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi

; 246  : }

  000a5	c2 04 00	 ret	 4
?Exec@CQuery@@QAEHPBD@Z ENDP				; CQuery::Exec
_TEXT	ENDS
PUBLIC	?MoreResults@CQuery@@QAEHXZ			; CQuery::MoreResults
PUBLIC	??_C@_0P@PHEABAGN@SQLMoreResults?$AA@		; `string'
EXTRN	_SQLMoreResults@4:NEAR
;	COMDAT ??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
CONST	SEGMENT
??_C@_0P@PHEABAGN@SQLMoreResults?$AA@ DB 'SQLMoreResults', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MoreResults@CQuery@@QAEHXZ
_TEXT	SEGMENT
?MoreResults@CQuery@@QAEHXZ PROC NEAR			; CQuery::MoreResults, COMDAT
; _this$ = ecx

; 249  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 250  : //	Clear();	//       .
; 251  : 	
; 252  : 	SQLRETURN ret = SQLMoreResults( hStmt );

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLMoreResults@4

; 253  : 	switch( ret ) {

  0000f	0f bf c0	 movsx	 eax, ax
  00012	85 c0		 test	 eax, eax
  00014	7c 0d		 jl	 SHORT $L148111
  00016	83 f8 01	 cmp	 eax, 1
  00019	7f 08		 jg	 SHORT $L148111

; 260  : 	}
; 261  : 
; 262  : 	return PrepareFetch();

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
$L148111:

; 254  : 	case SQL_SUCCESS:
; 255  : 	case SQL_SUCCESS_WITH_INFO:
; 256  : 		break;
; 257  : 	default:
; 258  : 		PrintDiag( "SQLMoreResults", SQL_HANDLE_STMT );	

  00023	6a 03		 push	 3
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 259  : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 263  : }

  00034	c3		 ret	 0
?MoreResults@CQuery@@QAEHXZ ENDP			; CQuery::MoreResults
_TEXT	ENDS
PUBLIC	?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z	; CQuery::Exec
; Function compile flags: /Ogty
;	COMDAT ?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z
_TEXT	SEGMENT
_szSQL$ = 8						; size = 4
_nCount$ = 12						; size = 4
_infos$ = 16						; size = 4
?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z PROC NEAR	; CQuery::Exec, COMDAT
; _this$ = ecx

; 267  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 268  : 	Clear();	//       .

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00010	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00016	6a 02		 push	 2
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 269  : 
; 270  : 	SQLRETURN ret = SQLExecDirect( hStmt, (SQLCHAR*)szSQL, lstrlen( szSQL ) );

  0001e	8b 7c 24 0c	 mov	 edi, DWORD PTR _szSQL$[esp+4]
  00022	57		 push	 edi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00029	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 271  : 	switch( ret )

  00037	0f bf c0	 movsx	 eax, ax
  0003a	85 c0		 test	 eax, eax
  0003c	7c 0a		 jl	 SHORT $L148126
  0003e	83 f8 01	 cmp	 eax, 1
  00041	7e 52		 jle	 SHORT $L148129
  00043	83 f8 64	 cmp	 eax, 100		; 00000064H

; 272  : 	{
; 273  : 	case SQL_SUCCESS_WITH_INFO:
; 274  : #ifdef _DEBUG
; 275  : 		PrintDiag( szSQL, SQL_HANDLE_STMT );	
; 276  : #endif
; 277  : 		//    
; 278  : 	case SQL_SUCCESS:
; 279  : 	case SQL_NO_DATA_FOUND:
; 280  : 		break;

  00046	74 4d		 je	 SHORT $L148129
$L148126:

; 281  : 	default:
; 282  : 		{
; 283  : 			PrintDiag( szSQL, SQL_HANDLE_STMT );	

  00048	6a 03		 push	 3
  0004a	57		 push	 edi
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 284  : 			DisConnect();

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?DisConnect@CQuery@@QAEXXZ ; CQuery::DisConnect

; 285  : 			if( Connect( 3, DBName, DBId, DBPass ) )

  00059	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0005f	50		 push	 eax
  00060	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	6a 03		 push	 3
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  00071	85 c0		 test	 eax, eax
  00073	74 2c		 je	 SHORT $L148127

; 286  : 			{
; 287  : 				ret = SQLExecDirect( hStmt, (SQLCHAR *)szSQL, SQL_NTS );

  00075	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0007b	6a fd		 push	 -3			; fffffffdH
  0007d	57		 push	 edi
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 288  : 				if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO) && (ret != SQL_NO_DATA)) 

  00084	66 85 c0	 test	 ax, ax
  00087	74 0c		 je	 SHORT $L148129
  00089	66 3d 01 00	 cmp	 ax, 1
  0008d	74 06		 je	 SHORT $L148129
  0008f	66 3d 64 00	 cmp	 ax, 100			; 00000064H

; 289  : 					return FALSE;

  00093	75 0c		 jne	 SHORT $L148127
$L148129:

; 293  : 		}
; 294  : 	}
; 295  : 
; 296  : 	return PrepareFetch();

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 297  : }

  0009e	c2 0c 00	 ret	 12			; 0000000cH
$L148127:
  000a1	5f		 pop	 edi

; 290  : 			}
; 291  : 			else
; 292  : 				return FALSE;

  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi

; 297  : }

  000a5	c2 0c 00	 ret	 12			; 0000000cH
?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z ENDP	; CQuery::Exec
_TEXT	ENDS
PUBLIC	?Execute@CQuery@@QAAHPBDZZ			; CQuery::Execute
; Function compile flags: /Ogty
;	COMDAT ?Execute@CQuery@@QAAHPBDZZ
_TEXT	SEGMENT
_szQuery$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Execute@CQuery@@QAAHPBDZZ PROC NEAR			; CQuery::Execute, COMDAT

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	57		 push	 edi
  00012	89 84 24 0c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1040], eax

; 672  : 	char szQuery[1024]		= { 0,};

  00019	33 c0		 xor	 eax, eax
  0001b	c6 44 24 08 00	 mov	 BYTE PTR _szQuery$[esp+1040], 0
  00020	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00025	8d 7c 24 09	 lea	 edi, DWORD PTR _szQuery$[esp+1041]
  00029	f3 ab		 rep stosd

; 673  : 	va_list	args;
; 674  : 	va_start( args, lpszFormat );
; 675  : 	int n	= _vsntprintf( szQuery, 1024, lpszFormat, args );

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszFormat$[ebp]
  0002e	66 ab		 stosw
  00030	aa		 stosb
  00031	8d 45 10	 lea	 eax, DWORD PTR _lpszFormat$[ebp+4]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 54 24 10	 lea	 edx, DWORD PTR _szQuery$[esp+1048]
  0003a	68 00 04 00 00	 push	 1024			; 00000400H
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 __vsnprintf
  00045	83 c4 10	 add	 esp, 16			; 00000010H

; 676  : 	va_end( args );
; 677  : 	return n > 0 && Exec( szQuery );

  00048	85 c0		 test	 eax, eax
  0004a	7e 27		 jle	 SHORT $L148630
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8d 44 24 08	 lea	 eax, DWORD PTR _szQuery$[esp+1040]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00059	85 c0		 test	 eax, eax
  0005b	74 16		 je	 SHORT $L148630
  0005d	b8 01 00 00 00	 mov	 eax, 1

; 678  : }

  00062	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1040]
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	5f		 pop	 edi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$L148630:
  00073	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1040]
  0007a	33 c0		 xor	 eax, eax
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	5f		 pop	 edi
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?Execute@CQuery@@QAAHPBDZZ ENDP				; CQuery::Execute
_TEXT	ENDS
END
