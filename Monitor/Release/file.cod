; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\Offi SRC_real\Offi src!\_Common\file.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Close@CFileIO@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CFileIO@@UAEHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CFileIO@@UAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutWideString@CFileIO@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileFinder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileFinder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WildCmp@CFileFinder@@QAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindClose@CFileFinder@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Write@CFileIO@@QAEIPAXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_mbstowcsz@ATL@@YAHPAGPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	?Close@CFileIO@@UAEHXZ				; CFileIO::Close
EXTRN	_fclose:NEAR
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\file.cpp
;	COMDAT ?Close@CFileIO@@UAEHXZ
_TEXT	SEGMENT
?Close@CFileIO@@UAEHXZ PROC NEAR			; CFileIO::Close, COMDAT
; _this$ = ecx

; 17   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 18   : 	if( fp ) 

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 17		 je	 SHORT $L147945

; 19   : 	{ 
; 20   : 		fclose( fp ); 

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fclose
  00010	83 c4 04	 add	 esp, 4

; 21   : 		fp = 0; 

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 22   : 		return TRUE; 

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5e		 pop	 esi

; 25   : }

  00020	c3		 ret	 0
$L147945:

; 23   : 	}
; 24   : 	return FALSE;

  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 25   : }

  00024	c3		 ret	 0
?Close@CFileIO@@UAEHXZ ENDP				; CFileIO::Close
_TEXT	ENDS
PUBLIC	?Open@CFileIO@@UAEHPBDPAD@Z			; CFileIO::Open
EXTRN	_fopen:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Open@CFileIO@@UAEHPBDPAD@Z
_TEXT	SEGMENT
_fileName$ = 8						; size = 4
_mode$ = 12						; size = 4
?Open@CFileIO@@UAEHPBDPAD@Z PROC NEAR			; CFileIO::Open, COMDAT
; _this$ = ecx

; 29   : 	fp = _tfopen( fileName, mode );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _mode$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _fileName$[esp]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _fopen

; 30   : 	if( fp )

  00012	33 d2		 xor	 edx, edx
  00014	83 c4 08	 add	 esp, 8
  00017	85 c0		 test	 eax, eax
  00019	0f 95 c2	 setne	 dl
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001f	5e		 pop	 esi
  00020	8b c2		 mov	 eax, edx

; 31   : 		return TRUE;
; 32   : 	return FALSE;
; 33   : }

  00022	c2 08 00	 ret	 8
?Open@CFileIO@@UAEHPBDPAD@Z ENDP			; CFileIO::Open
_TEXT	ENDS
PUBLIC	?Read@CFileIO@@UAEPAXXZ				; CFileIO::Read
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	_fread:NEAR
EXTRN	_fseek:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Read@CFileIO@@UAEPAXXZ
_TEXT	SEGMENT
?Read@CFileIO@@UAEPAXXZ PROC NEAR			; CFileIO::Read, COMDAT
; _this$ = ecx

; 36   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 37   : 	long size = GetLength();

  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	57		 push	 edi
  00007	ff 50 24	 call	 DWORD PTR [eax+36]
  0000a	8b d8		 mov	 ebx, eax

; 38   : 	LPVOID ptr = new BYTE[ size ];

  0000c	53		 push	 ebx
  0000d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 04	 add	 esp, 4

; 39   : 	if( !ptr ) 

  00017	85 ff		 test	 edi, edi

; 40   : 		return NULL;

  00019	74 30		 je	 SHORT $L148062

; 41   : 
; 42   : 	fseek( fp, 0, SEEK_SET );

  0001b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 _fseek

; 43   : 	if( fread( ptr, size, 1, fp ) ) 

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	52		 push	 edx
  0002c	6a 01		 push	 1
  0002e	53		 push	 ebx
  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 _fread
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH
  00038	85 c0		 test	 eax, eax
  0003a	74 06		 je	 SHORT $L147961

; 44   : 	{ 
; 45   : 		return ptr;

  0003c	8b c7		 mov	 eax, edi
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 49   : }

  00041	c3		 ret	 0
$L147961:

; 46   : 	}
; 47   : 	safe_delete_array( ptr ); 

  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00048	83 c4 04	 add	 esp, 4
$L148062:
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 48   : 	return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	5b		 pop	 ebx

; 49   : }

  00050	c3		 ret	 0
?Read@CFileIO@@UAEPAXXZ ENDP				; CFileIO::Read
_TEXT	ENDS
PUBLIC	??0CFileFinder@@QAE@XZ				; CFileFinder::CFileFinder
; Function compile flags: /Ogty
;	COMDAT ??0CFileFinder@@QAE@XZ
_TEXT	SEGMENT
??0CFileFinder@@QAE@XZ PROC NEAR			; CFileFinder::CFileFinder, COMDAT
; _this$ = ecx

; 670  : {

  00000	8b c1		 mov	 eax, ecx

; 671  : 	m_pos = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 672  : 	m_lHandle = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 673  : 	m_bResFile = FALSE;

  00009	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 674  : }

  0000f	c3		 ret	 0
??0CFileFinder@@QAE@XZ ENDP				; CFileFinder::CFileFinder
_TEXT	ENDS
PUBLIC	??1CFileFinder@@QAE@XZ				; CFileFinder::~CFileFinder
; Function compile flags: /Ogty
;	COMDAT ??1CFileFinder@@QAE@XZ
_TEXT	SEGMENT
??1CFileFinder@@QAE@XZ PROC NEAR			; CFileFinder::~CFileFinder, COMDAT
; _this$ = ecx

; 677  : }

  00000	c3		 ret	 0
??1CFileFinder@@QAE@XZ ENDP				; CFileFinder::~CFileFinder
_TEXT	ENDS
PUBLIC	?WildCmp@CFileFinder@@QAEHPBD0@Z		; CFileFinder::WildCmp
; Function compile flags: /Ogty
;	COMDAT ?WildCmp@CFileFinder@@QAEHPBD0@Z
_TEXT	SEGMENT
_cp$ = 8						; size = 4
_mp$ = 8						; size = 4
_lpszWild$ = 8						; size = 4
_lpszString$ = 12					; size = 4
?WildCmp@CFileFinder@@QAEHPBD0@Z PROC NEAR		; CFileFinder::WildCmp, COMDAT
; _this$ = ecx

; 681  : 	char* wild = (char*)lpszWild;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lpszWild$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 682  :     char* string = (char*)lpszString;

  00006	8b 74 24 10	 mov	 esi, DWORD PTR _lpszString$[esp+4]

; 683  : 	char* cp,* mp;
; 684  : 
; 685  : 	while ((*string) && (*wild != '*')) 

  0000a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000d	57		 push	 edi
  0000e	74 42		 je	 SHORT $L148073
$L147988:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00015	74 3b		 je	 SHORT $L148073

; 686  : 	{
; 687  : 		if ((*wild != *string) && (*wild != '?')) 

  00017	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00019	74 05		 je	 SHORT $L147990
  0001b	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  0001e	75 2a		 jne	 SHORT $L148075
$L147990:

; 683  : 	char* cp,* mp;
; 684  : 
; 685  : 	while ((*string) && (*wild != '*')) 

  00020	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]

; 690  : 		}
; 691  : 		wild++;

  00023	40		 inc	 eax

; 692  : 		string++;

  00024	46		 inc	 esi
  00025	84 c9		 test	 cl, cl
  00027	75 e7		 jne	 SHORT $L147988
$L148074:

; 715  : 		}
; 716  : 	}
; 717  : 	while (*wild == '*') 

  00029	80 38 2a	 cmp	 BYTE PTR [eax], 42	; 0000002aH
  0002c	75 0b		 jne	 SHORT $L148002
  0002e	8b ff		 npad	 2
$L148001:
  00030	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 718  : 	{
; 719  : 		wild++;

  00033	40		 inc	 eax
  00034	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00037	74 f7		 je	 SHORT $L148001
$L148002:

; 720  : 	}
; 721  : 	return !*wild;

  00039	8a 10		 mov	 dl, BYTE PTR [eax]
  0003b	33 c9		 xor	 ecx, ecx
  0003d	84 d2		 test	 dl, dl
  0003f	0f 94 c1	 sete	 cl
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b c1		 mov	 eax, ecx

; 722  : }

  00047	c2 08 00	 ret	 8
$L148075:
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 688  : 		{
; 689  : 			return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5b		 pop	 ebx

; 722  : }

  0004f	c2 08 00	 ret	 8
$L148073:

; 693  : 	}
; 694  : 	while (*string) 

  00052	8a 16		 mov	 dl, BYTE PTR [esi]
  00054	84 d2		 test	 dl, dl
  00056	74 d1		 je	 SHORT $L148074
  00058	8b 5c 24 10	 mov	 ebx, DWORD PTR _mp$[esp+8]
  0005c	8b 7c 24 10	 mov	 edi, DWORD PTR _cp$[esp+8]
$L147992:

; 695  : 	{
; 696  : 		if (*wild == '*') 

  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00065	75 0f		 jne	 SHORT $L147994

; 697  : 		{
; 698  : 			if (!*++wild) 

  00067	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0006a	40		 inc	 eax
  0006b	84 c9		 test	 cl, cl
  0006d	74 21		 je	 SHORT $L148076

; 701  : 			}
; 702  : 			mp = wild;

  0006f	8b d8		 mov	 ebx, eax

; 703  : 			cp = string+1;

  00071	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 704  : 		} 
; 705  : 		else 

  00074	eb 12		 jmp	 SHORT $L147999
$L147994:

; 706  : 		if ((*wild == *string) || (*wild == '?')) 

  00076	3a ca		 cmp	 cl, dl
  00078	74 0c		 je	 SHORT $L147998
  0007a	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  0007d	74 07		 je	 SHORT $L147998

; 710  : 		} 
; 711  : 		else 
; 712  : 		{
; 713  : 			wild = mp;
; 714  : 			string = cp++;

  0007f	8b f7		 mov	 esi, edi
  00081	8b c3		 mov	 eax, ebx
  00083	47		 inc	 edi
  00084	eb 02		 jmp	 SHORT $L147999
$L147998:

; 707  : 		{
; 708  : 			wild++;

  00086	40		 inc	 eax

; 709  : 			string++;

  00087	46		 inc	 esi
$L147999:
  00088	8a 16		 mov	 dl, BYTE PTR [esi]
  0008a	84 d2		 test	 dl, dl
  0008c	75 d2		 jne	 SHORT $L147992

; 697  : 		{
; 698  : 			if (!*++wild) 

  0008e	eb 99		 jmp	 SHORT $L148074
$L148076:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 699  : 			{
; 700  : 				return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	5b		 pop	 ebx

; 722  : }

  00098	c2 08 00	 ret	 8
?WildCmp@CFileFinder@@QAEHPBD0@Z ENDP			; CFileFinder::WildCmp
_TEXT	ENDS
PUBLIC	?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z ; CFileFinder::FindFirst
EXTRN	__findfirst:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z
_TEXT	SEGMENT
_lpFilespec$ = 8					; size = 4
_fileinfo$ = 12						; size = 4
?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z PROC NEAR ; CFileFinder::FindFirst, COMDAT
; _this$ = ecx

; 726  : #if defined( __CLIENT )
; 727  : 	CHAR filespec[ MAX_PATH ];
; 728  : 	strcpy( filespec, lpFilespec );
; 729  : 	strlwr( filespec );
; 730  : 
; 731  : 	CHAR szPath [ MAX_PATH ];
; 732  : 	CHAR szFile[ MAX_PATH ];
; 733  : 
; 734  : 	TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], name[ _MAX_FNAME ], ext[_MAX_EXT];
; 735  : 	_splitpath( lpFilespec, drive, dir, name, ext );
; 736  : 
; 737  : 	// 드라이브명이 들어 있으면 완전한 path다. 그러므로 그냥 카피 
; 738  : 	if( drive[ 0 ] )
; 739  : 	{
; 740  : 		_tcscpy( m_szFilespec, lpFilespec );
; 741  : 	}
; 742  : 	// 드리이브명이 없으면 현재 path의 연장이다. 
; 743  : 	else
; 744  : 	{
; 745  : 		::GetCurrentDirectory( MAX_PATH, szPath );
; 746  : 		_tcscpy( m_szFilespec, szPath );
; 747  : 		_tcscat( m_szFilespec, "\\" );
; 748  : 		_tcscat( m_szFilespec, lpFilespec );
; 749  : 	}
; 750  : 	strlwr( m_szFilespec );
; 751  : 
; 752  : 	CString strNameName;
; 753  : 	RESOURCE* lpRes;
; 754  : 	m_pos = CResFile::m_mapResource.GetStartPosition();
; 755  : 	while( m_pos )
; 756  : 	{
; 757  : 		CResFile::m_mapResource.GetNextAssoc( m_pos, strNameName, (void*&) lpRes );
; 758  : 		_tcscpy( szFile, szPath );
; 759  : 		_tcscat( szFile, "\\" );
; 760  : 		_tcscat( szFile, strNameName );
; 761  : 		strlwr( szFile );
; 762  : 
; 763  : 		if( WildCmp( m_szFilespec, szFile ) )
; 764  : 		{
; 765  : 			_splitpath( strNameName, drive, dir, name, ext );
; 766  : 			strcpy( fileinfo->name, name );
; 767  : 			strcat( fileinfo->name, ext );
; 768  : 			fileinfo->size = lpRes->dwFileSize;
; 769  : 			fileinfo->attrib = _A_NORMAL;
; 770  : 			m_bResFile = TRUE;
; 771  : 			return TRUE;
; 772  : 		}
; 773  : 	}
; 774  : #endif	// __CLIENT
; 775  : 	m_bResFile = 0;
; 776  : 	m_lHandle = _findfirst( lpFilespec, fileinfo );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _fileinfo$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _lpFilespec$[esp]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c7 86 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+268], 0
  00017	e8 00 00 00 00	 call	 __findfirst

; 777  : 	if( m_lHandle == -1 ) 

  0001c	33 d2		 xor	 edx, edx
  0001e	83 c4 08	 add	 esp, 8
  00021	83 f8 ff	 cmp	 eax, -1
  00024	0f 95 c2	 setne	 dl
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	5e		 pop	 esi
  0002b	8b c2		 mov	 eax, edx

; 778  : 		return FALSE;
; 779  : 	return TRUE;
; 780  : }

  0002d	c2 08 00	 ret	 8
?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z ENDP	; CFileFinder::FindFirst
_TEXT	ENDS
PUBLIC	?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z	; CFileFinder::FindNext
EXTRN	__findnext:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z
_TEXT	SEGMENT
_fileinfo$ = 8						; size = 4
?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z PROC NEAR	; CFileFinder::FindNext, COMDAT
; _this$ = ecx

; 783  : #if defined( __CLIENT )
; 784  : 	if( m_bResFile == 1 )
; 785  : 	{
; 786  : 		TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], name[ _MAX_FNAME ], ext[_MAX_EXT];
; 787  : 		CHAR szPath [MAX_PATH];
; 788  : 		CHAR szFile[MAX_PATH];
; 789  : 		CString strNameName;
; 790  : 		RESOURCE* lpRes;
; 791  : 		::GetCurrentDirectory( MAX_PATH, szPath );
; 792  : 
; 793  : 		while( m_pos )
; 794  : 		{
; 795  : 			CResFile::m_mapResource.GetNextAssoc( m_pos, strNameName, (void*&) lpRes );
; 796  : 			_tcscpy( szFile, szPath );
; 797  : 			_tcscat( szFile, "\\" );
; 798  : 			_tcscat( szFile, strNameName );
; 799  : 			strlwr( szFile );
; 800  : 
; 801  : 			if( WildCmp( m_szFilespec, szFile ) )
; 802  : 			{
; 803  : 				_splitpath( strNameName, drive, dir, name, ext );
; 804  : 				strcpy( fileinfo->name, name );
; 805  : 				strcat( fileinfo->name, ext );
; 806  : 				fileinfo->size = lpRes->dwFileSize;
; 807  : 				fileinfo->attrib = _A_NORMAL;
; 808  : 				return TRUE;
; 809  : 			}
; 810  : 		}
; 811  : 		return FALSE;
; 812  : 	}
; 813  : #endif	// __CLIENT
; 814  : 	if( _findnext( m_lHandle, fileinfo ) == 0 )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _fileinfo$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 __findnext
  0000e	83 c4 08	 add	 esp, 8
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 815  : 		return TRUE;
; 816  : 	return FALSE;
; 817  : }

  00016	c2 04 00	 ret	 4
?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z ENDP	; CFileFinder::FindNext
_TEXT	ENDS
PUBLIC	?FindClose@CFileFinder@@QAEXXZ			; CFileFinder::FindClose
EXTRN	__findclose:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindClose@CFileFinder@@QAEXXZ
_TEXT	SEGMENT
?FindClose@CFileFinder@@QAEXXZ PROC NEAR		; CFileFinder::FindClose, COMDAT
; _this$ = ecx

; 820  : 	if( m_bResFile == 0 && m_lHandle != -1 )

  00000	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  00006	85 c0		 test	 eax, eax
  00008	75 0f		 jne	 SHORT $L148017
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	74 07		 je	 SHORT $L148017

; 821  : 		_findclose( m_lHandle );

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 __findclose
  00018	59		 pop	 ecx
$L148017:

; 822  : }

  00019	c3		 ret	 0
?FindClose@CFileFinder@@QAEXXZ ENDP			; CFileFinder::FindClose
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	56		 push	 esi
  00009	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000d	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00015	6a 07		 push	 7
  00017	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001b	51		 push	 ecx
  0001c	68 04 10 00 00	 push	 4100			; 00001004H
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00028	85 c0		 test	 eax, eax
  0002a	74 21		 je	 SHORT $L148098

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002c	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00030	84 c0		 test	 al, al
  00032	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00036	74 15		 je	 SHORT $L148098
$L37004:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00038	0f be c0	 movsx	 eax, al
  0003b	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  0003e	41		 inc	 ecx
  0003f	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	84 c0		 test	 al, al
  00047	75 ef		 jne	 SHORT $L37004

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 14		 jne	 SHORT $L148099
$L148098:

; 121  : 		nACP = ::GetACP();

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00053	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  00054	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	c3		 ret	 0
$L148099:
  00061	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00012	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00015	50		 push	 eax
  00016	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00024	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  00029	75 0c		 jne	 SHORT $L37014
  0002b	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00030	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00035	73 05		 jae	 SHORT $L37015
$L37014:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00037	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L37015:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  0004e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00060	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?_mbstowcsz@ATL@@YAHPAGPBDK@Z			; ATL::_mbstowcsz
EXTRN	__imp__MultiByteToWideChar@24:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?_mbstowcsz@ATL@@YAHPAGPBDK@Z
_TEXT	SEGMENT
_wcstr$ = 8						; size = 4
_mbstr$ = 12						; size = 4
_count$ = 16						; size = 4
?_mbstowcsz@ATL@@YAHPAGPBDK@Z PROC NEAR			; ATL::_mbstowcsz, COMDAT

; 96   : 	// count is number of wchar_t's
; 97   : 	if (count == 0 && wcstr != NULL)

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b 74 24 08	 mov	 esi, DWORD PTR _wcstr$[esp]
  0000b	75 08		 jne	 SHORT $L38604
  0000d	85 f6		 test	 esi, esi
  0000f	74 04		 je	 SHORT $L38604

; 98   : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 105  : 	return result;
; 106  : }

  00014	c3		 ret	 0
$L38604:

; 99   : 
; 100  : 	int result = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, mbstr, -1,
; 101  : 		wcstr, count);

  00015	50		 push	 eax
  00016	8b 44 24 10	 mov	 eax, DWORD PTR _mbstr$[esp+4]
  0001a	56		 push	 esi
  0001b	6a ff		 push	 -1
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 102  : 	ATLASSERT(wcstr == NULL || result <= (int)count);
; 103  : 	if ((result > 0) && (wcstr != NULL))

  0002d	85 c0		 test	 eax, eax
  0002f	7e 0b		 jle	 SHORT $L38603
  00031	85 f6		 test	 esi, esi
  00033	74 07		 je	 SHORT $L38603

; 104  : 		wcstr[result-1] = 0;

  00035	66 c7 44 46 fe
	00 00		 mov	 WORD PTR [esi+eax*2-2], 0
$L38603:
  0003c	5e		 pop	 esi

; 105  : 	return result;
; 106  : }

  0003d	c3		 ret	 0
?_mbstowcsz@ATL@@YAHPAGPBDK@Z ENDP			; ATL::_mbstowcsz
_TEXT	ENDS
PUBLIC	?Write@CFileIO@@QAEIPAXII@Z			; CFileIO::Write
EXTRN	_fwrite:NEAR
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\file.h
;	COMDAT ?Write@CFileIO@@QAEIPAXII@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_n$ = 16						; size = 4
?Write@CFileIO@@QAEIPAXII@Z PROC NEAR			; CFileIO::Write, COMDAT
; _this$ = ecx

; 36   : 	size_t Write( LPVOID ptr, size_t size, size_t n = 1 ) { return fwrite( ptr, size, n, fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _n$[esp-4]
  00007	8b 54 24 08	 mov	 edx, DWORD PTR _size$[esp-4]
  0000b	50		 push	 eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _ptr$[esp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fwrite
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Write@CFileIO@@QAEIPAXII@Z ENDP			; CFileIO::Write
_TEXT	ENDS
PUBLIC	?PutWideString@CFileIO@@QAEHPBD@Z		; CFileIO::PutWideString
EXTRN	_wcslen:NEAR
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\file.cpp
;	COMDAT ?PutWideString@CFileIO@@QAEHPBD@Z
_TEXT	SEGMENT
_wszBuff$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpszString$ = 8					; size = 4
?PutWideString@CFileIO@@QAEHPBD@Z PROC NEAR		; CFileIO::PutWideString, COMDAT
; _this$ = ecx

; 51   : {

  00000	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	56		 push	 esi

; 52   : 	wchar_t wszBuff[ 1024 ];
; 53   : 	int nLen = strlen( lpszString );

  0000c	8b b4 24 0c 08
	00 00		 mov	 esi, DWORD PTR _lpszString$[esp+2052]
  00013	89 84 24 04 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2056], eax
  0001a	8b c6		 mov	 eax, esi
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx
  0001f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L148147:
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	40		 inc	 eax
  00025	84 c9		 test	 cl, cl
  00027	75 f9		 jne	 SHORT $L148147
  00029	2b c2		 sub	 eax, edx

; 54   : 
; 55   : 	ATL::_mbstowcsz(wszBuff, lpszString,nLen + 1 );

  0002b	40		 inc	 eax
  0002c	74 23		 je	 SHORT $L148141
  0002e	50		 push	 eax
  0002f	8d 44 24 0c	 lea	 eax, DWORD PTR _wszBuff$[esp+2064]
  00033	50		 push	 eax
  00034	6a ff		 push	 -1
  00036	56		 push	 esi
  00037	6a 00		 push	 0
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00046	85 c0		 test	 eax, eax
  00048	7e 07		 jle	 SHORT $L148141
  0004a	66 c7 44 44 06
	00 00		 mov	 WORD PTR _wszBuff$[esp+eax*2+2058], 0
$L148141:

; 56   : 
; 57   : 	return Write( wszBuff, wcslen( wszBuff ) * 2 );

  00051	8d 4c 24 08	 lea	 ecx, DWORD PTR _wszBuff$[esp+2060]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _wcslen
  0005b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0005e	52		 push	 edx
  0005f	d1 e0		 shl	 eax, 1
  00061	6a 01		 push	 1
  00063	50		 push	 eax
  00064	8d 44 24 18	 lea	 eax, DWORD PTR _wszBuff$[esp+2076]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _fwrite

; 58   : }

  0006e	8b 8c 24 1c 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2080]
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	81 c4 04 08 00
	00		 add	 esp, 2052		; 00000804H
  00085	c2 04 00	 ret	 4
?PutWideString@CFileIO@@QAEHPBD@Z ENDP			; CFileIO::PutWideString
_TEXT	ENDS
END
